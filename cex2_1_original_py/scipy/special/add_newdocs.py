# uncompyle6 version 3.9.0
# Python bytecode version base 2.7 (62211)
# Decompiled from: Python 3.10.9 | packaged by Anaconda, Inc. | (main, Mar  8 2023, 10:42:25) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: scipy\special\add_newdocs.pyc
# Compiled at: 2013-02-16 13:27:32
from __future__ import division, print_function, absolute_import
docdict = {}

def get(name):
    return docdict.get(name)


def add_newdoc(place, name, doc):
    docdict[('.').join((place, name))] = doc


add_newdoc('scipy.special', '_lambertw', '\n    Internal function, use `lambertw` instead.\n    ')
add_newdoc('scipy.special', 'airy', "\n    (Ai,Aip,Bi,Bip)=airy(z) calculates the Airy functions and their derivatives\n    evaluated at real or complex number z.  The Airy functions Ai and Bi\n    are two independent solutions of y''(x)=xy.  Aip and Bip are the first derivatives\n    evaluated at x of Ai and Bi respectively.\n    ")
add_newdoc('scipy.special', 'airye', '\n    (Aie,Aipe,Bie,Bipe)=airye(z) calculates the exponentially scaled Airy functions and\n    their derivatives evaluated at real or complex number z.\n    airye(z)[0:1] = airy(z)[0:1] * exp(2.0/3.0*z*sqrt(z))\n    airye(z)[2:3] = airy(z)[2:3] * exp(-abs((2.0/3.0*z*sqrt(z)).real))\n    ')
add_newdoc('scipy.special', 'bdtr', '\n    y=bdtr(k,n,p) returns the sum of the terms 0 through k of the\n    Binomial probability density:  sum(nCj p**j (1-p)**(n-j),j=0..k)\n    ')
add_newdoc('scipy.special', 'bdtrc', '\n    y=bdtrc(k,n,p) returns the sum of the terms k+1 through n of the\n    Binomial probability density: sum(nCj p**j (1-p)**(n-j), j=k+1..n)\n    ')
add_newdoc('scipy.special', 'bdtri', '\n    p=bdtri(k,n,y) finds the probability p such that the sum of the\n    terms 0 through k of the Binomial probability density is equal to the\n    given cumulative probability y.\n    ')
add_newdoc('scipy.special', 'bdtrik', '\n    ')
add_newdoc('scipy.special', 'bdtrin', '\n    ')
add_newdoc('scipy.special', 'binom', '\n    binom(n, k)\n\n    Binomial coefficient\n    ')
add_newdoc('scipy.special', 'btdtria', '\n    ')
add_newdoc('scipy.special', 'btdtrib', '\n    ')
add_newdoc('scipy.special', 'bei', '\n    y=bei(x) returns the Kelvin function bei x\n    ')
add_newdoc('scipy.special', 'beip', '\n    y=beip(x) returns the derivative of the Kelvin function bei x\n    ')
add_newdoc('scipy.special', 'ber', '\n    y=ber(x) returns the Kelvin function ber x\n    ')
add_newdoc('scipy.special', 'berp', '\n    y=berp(x) returns the derivative of the Kelvin function ber x\n    ')
add_newdoc('scipy.special', 'besselpoly', '\n    y=besselpoly(a,lam,nu) returns the value of the integral:\n    integral(x**lam * jv(nu,2*a*x),x=0..1).\n    ')
add_newdoc('scipy.special', 'beta', '\n    y=beta(a,b) returns gamma(a) * gamma(b) / gamma(a+b)\n    ')
add_newdoc('scipy.special', 'betainc', '\n    betainc(a, b, x)\n\n    Compute the incomplete beta integral of the arguments, evaluated\n    from zero to x::\n\n        gamma(a+b) / (gamma(a)*gamma(b)) * integral(t**(a-1) (1-t)**(b-1), t=0..x).\n\n    Notes\n    -----\n    The incomplete beta is also sometimes defined without the terms\n    in gamma, in which case the above definition is the so-called regularized\n    incomplete beta. Under this definition, you can get the incomplete beta by\n    multiplying the result of the scipy function by beta(a, b).\n\n    ')
add_newdoc('scipy.special', 'betaincinv', '\n    betaincinv(a,b,y)\n\n    Compute x such that betainc(a,b,x) = y.\n    ')
add_newdoc('scipy.special', 'betaln', '\n    y=betaln(a,b) returns the natural logarithm of the absolute value of\n    beta: ln(abs(beta(x))).\n    ')
add_newdoc('scipy.special', 'btdtr', '\n    y=btdtr(a,b,x) returns the area from zero to x under the beta\n    density function: gamma(a+b)/(gamma(a)*gamma(b)))*integral(t**(a-1)\n    (1-t)**(b-1), t=0..x).  SEE ALSO betainc\n    ')
add_newdoc('scipy.special', 'btdtri', '\n    x=btdtri(a,b,p) returns the pth quantile of the beta distribution.  It is\n    effectively the inverse of btdtr returning the value of x for which\n    btdtr(a,b,x) = p.   SEE ALSO betaincinv\n    ')
add_newdoc('scipy.special', 'cbrt', '\n    y=cbrt(x) returns the real cube root of x.\n    ')
add_newdoc('scipy.special', 'chdtr', '\n    p=chdtr(v,x) Returns the area under the left hand tail (from 0 to x) of the Chi\n    square probability density function with v degrees of freedom:\n    1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=0..x)\n    ')
add_newdoc('scipy.special', 'chdtrc', '\n    p=chdtrc(v,x) returns the area under the right hand tail (from x to\n    infinity) of the Chi square probability density function with v\n    degrees of freedom:\n    1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=x..inf)\n    ')
add_newdoc('scipy.special', 'chdtri', '\n    x=chdtri(v,p) returns the argument x such that chdtrc(v,x) is equal\n    to p.\n    ')
add_newdoc('scipy.special', 'chdtriv', '\n    ')
add_newdoc('scipy.special', 'chndtr', '\n    ')
add_newdoc('scipy.special', 'chndtrix', '\n    ')
add_newdoc('scipy.special', 'chndtridf', '\n    ')
add_newdoc('scipy.special', 'chndtrinc', '\n    ')
add_newdoc('scipy.special', 'cosdg', '\n    y=cosdg(x) calculates the cosine of the angle x given in degrees.\n    ')
add_newdoc('scipy.special', 'cosm1', '\n    y=calculates cos(x) - 1 for use when x is near zero.\n    ')
add_newdoc('scipy.special', 'cotdg', '\n    y=cotdg(x) calculates the cotangent of the angle x given in degrees.\n    ')
add_newdoc('scipy.special', 'dawsn', "\n    y=dawsn(x) returns dawson's integral: exp(-x**2) *\n    integral(exp(t**2),t=0..x).\n\n    References\n    ----------\n    .. [1] Steven G. Johnson, Faddeeva W function implementation.\n       http://ab-initio.mit.edu/Faddeeva\n    ")
add_newdoc('scipy.special', 'ellipe', '\n    y=ellipe(m) returns the complete integral of the second kind:\n    integral(sqrt(1-m*sin(t)**2),t=0..pi/2)\n    ')
add_newdoc('scipy.special', 'ellipeinc', '\n    y=ellipeinc(phi,m) returns the incomplete elliptic integral of the\n    second kind: integral(sqrt(1-m*sin(t)**2),t=0..phi)\n    ')
add_newdoc('scipy.special', 'ellipj', '\n    (sn,cn,dn,ph)=ellipj(u,m) calculates the Jacobian elliptic functions of\n    parameter m between 0 and 1, and real u.  The returned functions are\n    often written sn(u|m), cn(u|m), and dn(u|m).  The value of ph is such\n    that if u = ellik(ph,m), then sn(u|m) = sin(ph) and cn(u|m) = cos(ph).\n    ')
add_newdoc('scipy.special', 'ellipkm1', '\n    y=ellipkm1(1 - m) returns the complete integral of the first kind:\n    integral(1/sqrt(1-m*sin(t)**2),t=0..pi/2)\n    ')
add_newdoc('scipy.special', 'ellipkinc', '\n    y=ellipkinc(phi,m) returns the incomplete elliptic integral of the first\n    kind: integral(1/sqrt(1-m*sin(t)**2),t=0..phi)\n    ')
add_newdoc('scipy.special', 'erf', '\n    erf(z)\n\n    Returns the error function of complex argument.\n\n    It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.\n\n    Parameters\n    ----------\n    x : ndarray\n        Input array.\n\n    Returns\n    -------\n    res : ndarray\n        The values of the error function at the given points x.\n\n    See Also\n    --------\n    erfc, erfinv, erfcinv\n\n    Notes\n    -----\n    The cumulative of the unit normal distribution is given by\n    ``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.\n\n    References\n    ----------\n    .. [1] http://en.wikipedia.org/wiki/Error_function\n    .. [2] Milton Abramowitz and Irene A. Stegun, eds.\n        Handbook of Mathematical Functions with Formulas,\n        Graphs, and Mathematical Tables. New York: Dover,\n        1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm\n    .. [3] Steven G. Johnson, Faddeeva W function implementation.\n       http://ab-initio.mit.edu/Faddeeva\n\n    ')
add_newdoc('scipy.special', 'erfc', '\n    y=erfc(x) returns 1 - erf(x).\n\n    References\n    ----------\n    .. [1] Steven G. Johnson, Faddeeva W function implementation.\n       http://ab-initio.mit.edu/Faddeeva\n\n    ')
add_newdoc('scipy.special', 'erfi', '\n    Imaginary error function, -i erf(i z)\n\n    .. versionadded:: 0.12.0\n\n    References\n    ----------\n    .. [1] Steven G. Johnson, Faddeeva W function implementation.\n       http://ab-initio.mit.edu/Faddeeva\n\n    ')
add_newdoc('scipy.special', 'erfcx', '\n    Scaled complementary error function, exp(x^2) erfc(x)\n\n    .. versionadded:: 0.12.0\n\n    References\n    ----------\n    .. [1] Steven G. Johnson, Faddeeva W function implementation.\n       http://ab-initio.mit.edu/Faddeeva\n\n    ')
add_newdoc('scipy.special', 'eval_jacobi', '\n    eval_jacobi(n, alpha, beta, x, out=None)\n\n    Evaluate Jacobi polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_sh_jacobi', '\n    eval_sh_jacobi(n, p, q, x, out=None)\n\n    Evaluate shifted Jacobi polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_gegenbauer', '\n    eval_gegenbauer(n, alpha, x, out=None)\n\n    Evaluate Gegenbauer polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_chebyt', '\n    eval_chebyt(n, x, out=None)\n\n    Evaluate Chebyshev T polynomial at a point.\n\n    This routine is numerically stable for `x` in ``[-1, 1]`` at least\n    up to order ``10000``.\n    ')
add_newdoc('scipy.special', 'eval_chebyu', '\n    eval_chebyu(n, x, out=None)\n\n    Evaluate Chebyshev U polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_chebys', '\n    eval_chebys(n, x, out=None)\n\n    Evaluate Chebyshev S polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_chebyc', '\n    eval_chebyc(n, x, out=None)\n\n    Evaluate Chebyshev C polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_sh_chebyt', '\n    eval_sh_chebyt(n, x, out=None)\n\n    Evaluate shifted Chebyshev T polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_sh_chebyu', '\n    eval_sh_chebyu(n, x, out=None)\n\n    Evaluate shifted Chebyshev U polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_legendre', '\n    eval_legendre(n, x, out=None)\n\n    Evaluate Legendre polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_sh_legendre', '\n    eval_sh_legendre(n, x, out=None)\n\n    Evaluate shifted Legendre polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_genlaguerre', '\n    eval_genlaguerre(n, alpha, x, out=None)\n\n    Evaluate generalized Laguerre polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_laguerre', '\n    eval_laguerre(n, x, out=None)\n\n    Evaluate Laguerre polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_hermite', '\n    eval_hermite(n, x, out=None)\n\n    Evaluate Hermite polynomial at a point.\n    ')
add_newdoc('scipy.special', 'eval_hermitenorm', '\n    eval_hermitenorm(n, x, out=None)\n\n    Evaluate normalized Hermite polynomial at a point.\n    ')
add_newdoc('scipy.special', 'exp1', '\n    y=exp1(z) returns the exponential integral (n=1) of complex argument\n    z: integral(exp(-z*t)/t,t=1..inf).\n    ')
add_newdoc('scipy.special', 'exp10', '\n    y=exp10(x) returns 10 raised to the x power.\n    ')
add_newdoc('scipy.special', 'exp2', '\n    y=exp2(x) returns 2 raised to the x power.\n    ')
add_newdoc('scipy.special', 'expi', '\n    y=expi(x) returns an exponential integral of argument x defined as\n    integral(exp(t)/t,t=-inf..x).  See expn for a different exponential\n    integral.\n    ')
add_newdoc('scipy.special', 'expit', '\n    Expit ufunc for ndarrays.\n\n    The expit function is defined as expit(x) = 1/(1+exp(-x)).\n    Note that expit is the inverse logit function.\n\n    Parameters\n    ----------\n    x : ndarray\n        The ndarray to apply expit to element-wise.\n\n    Returns\n    -------\n    out : ndarray\n        An ndarray of the same shape as x. Its entries\n        are expit of the corresponding entry of x.\n\n    Notes\n    -----\n    As a ufunc logit takes a number of optional\n    keywork arguments. For more information\n    see `ufuncs <http://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n    ')
add_newdoc('scipy.special', 'expm1', '\n    y=expm1(x) calculates exp(x) - 1 for use when x is near zero.\n    ')
add_newdoc('scipy.special', 'expn', '\n    y=expn(n,x) returns the exponential integral for integer n and\n    non-negative x and n: integral(exp(-x*t) / t**n, t=1..inf).\n    ')
add_newdoc('scipy.special', 'fdtr', "\n    y=fdtr(dfn,dfd,x) returns the area from zero to x under the F density\n    function (also known as Snedcor's density or the variance ratio\n    density).  This is the density of X = (unum/dfn)/(uden/dfd), where unum and\n    uden are random variables having Chi square distributions with dfn and\n    dfd degrees of freedom, respectively.\n    ")
add_newdoc('scipy.special', 'fdtrc', '\n    y=fdtrc(dfn,dfd,x) returns the complemented F distribution function.\n    ')
add_newdoc('scipy.special', 'fdtri', '\n    x=fdtri(dfn,dfd,p) finds the F density argument x such that\n    fdtr(dfn,dfd,x)=p.\n    ')
add_newdoc('scipy.special', 'fdtridfd', '\n    x=fdtridfd(dfn,p,x) finds the F density argument dfd such that\n    fdtr(dfn,dfd,x)=p.\n    ')
add_newdoc('scipy.special', 'fdtridfn', '\n    x=fdtridfn(p,dfd,x) finds the F density argument dfn such that\n    fdtr(dfn,dfd,x)=p.\n    ')
add_newdoc('scipy.special', 'fresnel', '\n    (ssa,cca)=fresnel(z) returns the Fresnel sin and cos integrals: integral(sin(pi/2\n    * t**2),t=0..z) and integral(cos(pi/2 * t**2),t=0..z) for real or\n    complex z.\n    ')
add_newdoc('scipy.special', 'gamma', '\n    y=gamma(z) returns the gamma function of the argument.  The gamma\n    function is often referred to as the generalized factorial since\n    z*gamma(z) = gamma(z+1) and gamma(n+1) = n! for natural number n.\n    ')
add_newdoc('scipy.special', 'gammainc', '\n    y=gammainc(a,x) returns the incomplete gamma integral defined as\n    1 / gamma(a) * integral(exp(-t) * t**(a-1), t=0..x).  a must be\n    positive and x must be >= 0.\n    ')
add_newdoc('scipy.special', 'gammaincc', '\n    y=gammaincc(a,x) returns the complemented incomplete gamma integral\n    defined as 1 / gamma(a) * integral(exp(-t) * t**(a-1), t=x..inf) = 1 -\n    gammainc(a,x).  a must be positive and x must be >= 0.\n    ')
add_newdoc('scipy.special', 'gammainccinv', '\n    x=gammainccinv(a,y) returns x such that gammaincc(a,x) = y.\n    ')
add_newdoc('scipy.special', 'gammaincinv', '\n    gammaincinv(a, y) returns x such that gammainc(a, x) = y.\n    ')
add_newdoc('scipy.special', 'gammaln', '\n    y=gammaln(z) returns the base e logarithm of the absolute value of the\n    gamma function of z: ln(abs(gamma(z)))\n\n    See Also\n    --------\n    gammasgn\n    ')
add_newdoc('scipy.special', 'gammasgn', '\n    y=gammasgn(x) returns the sign of the gamma function.\n\n    See Also\n    --------\n    gammaln\n    ')
add_newdoc('scipy.special', 'gdtr', '\n    y=gdtr(a,b,x) returns the integral from zero to x of the gamma\n    probability density function: a**b / gamma(b) * integral(t**(b-1) exp(-at),t=0..x).\n    The arguments a and b are used differently here than in other definitions.\n    ')
add_newdoc('scipy.special', 'gdtrc', '\n    y=gdtrc(a,b,x) returns the integral from x to infinity of the gamma\n    probability density function.  SEE gdtr, gdtri\n    ')
add_newdoc('scipy.special', 'gdtri', '\n    x=gdtri(a,b,p) returns pth quantile of the gamma distribution.  It is\n    the inverse of the gamma cdf returning the value of x for which\n    gdtr(b,a,x) = p.\n    ')
add_newdoc('scipy.special', 'gdtria', '\n    ')
add_newdoc('scipy.special', 'gdtrib', '\n    ')
add_newdoc('scipy.special', 'gdtrix', '\n    ')
add_newdoc('scipy.special', 'hankel1', '\n    y=hankel1(v,z) returns the Hankel function of the first kind for real order v and complex argument z.\n    ')
add_newdoc('scipy.special', 'hankel1e', '\n    y=hankel1e(v,z) returns the exponentially scaled Hankel function of the first\n    kind for real order v and complex argument z:\n    hankel1e(v,z) = hankel1(v,z) * exp(-1j * z)\n    ')
add_newdoc('scipy.special', 'hankel2', '\n    y=hankel2(v,z) returns the Hankel function of the second kind for real order v and complex argument z.\n    ')
add_newdoc('scipy.special', 'hankel2e', '\n    y=hankel2e(v,z) returns the exponentially scaled Hankel function of the second\n    kind for real order v and complex argument z:\n    hankel1e(v,z) = hankel1(v,z) * exp(1j * z)\n    ')
add_newdoc('scipy.special', 'hyp1f1', '\n    y=hyp1f1(a,b,x) returns the confluent hypergeometeric function\n    ( 1F1(a,b;x) ) evaluated at the values a, b, and x.\n    ')
add_newdoc('scipy.special', 'hyp1f2', '\n    (y,err)=hyp1f2(a,b,c,x) returns (y,err) with the hypergeometric function 1F2 in y and an error estimate in err.\n    ')
add_newdoc('scipy.special', 'hyp2f0', '\n    (y,err)=hyp2f0(a,b,x,type) returns (y,err) with the hypergeometric function 2F0 in y and an error estimate in err.  The input type determines a convergence factor and\n    can be either 1 or 2.\n    ')
add_newdoc('scipy.special', 'hyp2f1', '\n    y=hyp2f1(a,b,c,z) returns the Gauss hypergeometric function\n    ( 2F1(a,b;c;z) ).\n    ')
add_newdoc('scipy.special', 'hyp3f0', '\n    (y,err)=hyp3f0(a,b,c,x) returns (y,err) with the hypergeometric function 3F0 in y and an error estimate in err.\n    ')
add_newdoc('scipy.special', 'hyperu', '\n    y=hyperu(a,b,x) returns the confluent hypergeometric function of the\n    second kind U(a,b,x).\n    ')
add_newdoc('scipy.special', 'i0', '\n    y=i0(x) returns the modified Bessel function of order 0 at x.\n    ')
add_newdoc('scipy.special', 'i0e', '\n    y=i0e(x) returns the exponentially scaled modified Bessel function\n    of order 0 at x.  i0e(x) = exp(-abs(x)) * i0(x).\n    ')
add_newdoc('scipy.special', 'i1', '\n    y=i1(x) returns the modified Bessel function of order 1 at x.\n    ')
add_newdoc('scipy.special', 'i1e', '\n    y=i1e(x) returns the exponentially scaled modified Bessel function\n    of order 0 at x.  i1e(x) = exp(-abs(x)) * i1(x).\n    ')
add_newdoc('scipy.special', 'it2i0k0', '\n    (ii0,ik0)=it2i0k0(x) returns the integrals int((i0(t)-1)/t,t=0..x) and\n    int(k0(t)/t,t=x..infinitity).\n    ')
add_newdoc('scipy.special', 'it2j0y0', '\n    (ij0,iy0)=it2j0y0(x) returns the integrals int((1-j0(t))/t,t=0..x) and\n    int(y0(t)/t,t=x..infinitity).\n    ')
add_newdoc('scipy.special', 'it2struve0', '\n    y=it2struve0(x) returns the integral of the Struve function of order 0\n    divided by t from x to infinity:  integral(H0(t)/t, t=x..inf).\n    ')
add_newdoc('scipy.special', 'itairy', '\n    (Apt,Bpt,Ant,Bnt)=itairy(x) calculates the integral of Airy functions from 0 to x\n    for positive (Apt, Bpt) and negative (Ant, Bnt) arguments.\n    ')
add_newdoc('scipy.special', 'iti0k0', '\n    (ii0,ik0)=iti0k0(x) returns simple integrals from 0 to x of the zeroth order\n    modified Bessel functions i0 and k0.\n    ')
add_newdoc('scipy.special', 'itj0y0', '\n    (ij0,iy0)=itj0y0(x) returns simple integrals from 0 to x of the zeroth order\n    Bessel functions j0 and y0.\n    ')
add_newdoc('scipy.special', 'itmodstruve0', '\n    y=itmodstruve0(x) returns the integral of the modified Struve function\n    of order 0 from 0 to x:  integral(L0(t), t=0..x).\n    ')
add_newdoc('scipy.special', 'itstruve0', '\n    y=itstruve0(x) returns the integral of the Struve function of order 0\n    from 0 to x:  integral(H0(t), t=0..x).\n    ')
add_newdoc('scipy.special', 'iv', '\n    y=iv(v,z) returns the modified Bessel function of real order v of\n    z.  If z is of real type and negative, v must be integer valued.\n    ')
add_newdoc('scipy.special', 'ive', '\n    y=ive(v,z) returns the exponentially scaled modified Bessel function of\n    real order v and complex z: ive(v,z) = iv(v,z) * exp(-abs(z.real))\n    ')
add_newdoc('scipy.special', 'j0', '\n    y=j0(x) returns the Bessel function of order 0 at x.\n    ')
add_newdoc('scipy.special', 'j1', '\n    y=j1(x) returns the Bessel function of order 1 at x.\n    ')
add_newdoc('scipy.special', 'jn', '\n    y=jn(n,x) returns the Bessel function of integer order n at  x.\n    ')
add_newdoc('scipy.special', 'jv', '\n    y=jv(v,z) returns the Bessel function of real order v at complex z.\n    ')
add_newdoc('scipy.special', 'jve', '\n    y=jve(v,z) returns the exponentially scaled Bessel function of real order\n    v at complex z: jve(v,z) = jv(v,z) * exp(-abs(z.imag))\n    ')
add_newdoc('scipy.special', 'k0', '\n    y=k0(x) returns the modified Bessel function of the second kind (sometimes called the third kind) of\n    order 0 at x.\n    ')
add_newdoc('scipy.special', 'k0e', '\n    y=k0e(x) returns the exponentially scaled modified Bessel function\n    of the second kind (sometimes called the third kind) of order 0 at x.  k0e(x) = exp(x) * k0(x).\n    ')
add_newdoc('scipy.special', 'k1', '\n    y=i1(x) returns the modified Bessel function of the second kind (sometimes called the third kind) of\n    order 1 at x.\n    ')
add_newdoc('scipy.special', 'k1e', '\n    y=k1e(x) returns the exponentially scaled modified Bessel function\n    of the second kind (sometimes called the third kind) of order 1 at x.  k1e(x) = exp(x) * k1(x)\n    ')
add_newdoc('scipy.special', 'kei', '\n    y=kei(x) returns the Kelvin function ker x\n    ')
add_newdoc('scipy.special', 'keip', '\n    y=keip(x) returns the derivative of the Kelvin function kei x\n    ')
add_newdoc('scipy.special', 'kelvin', '\n    (Be, Ke, Bep, Kep)=kelvin(x) returns the tuple (Be, Ke, Bep, Kep) which contains\n    complex numbers representing the real and imaginary Kelvin functions\n    and their derivatives evaluated at x.  For example,\n    kelvin(x)[0].real = ber x and kelvin(x)[0].imag = bei x with similar\n    relationships for ker and kei.\n    ')
add_newdoc('scipy.special', 'ker', '\n    y=ker(x) returns the Kelvin function ker x\n    ')
add_newdoc('scipy.special', 'kerp', '\n    y=kerp(x) returns the derivative of the Kelvin function ker x\n    ')
add_newdoc('scipy.special', 'kn', '\n    y=kn(n,x) returns the modified Bessel function of the second kind (sometimes called the third kind) for\n    integer order n at x.\n    ')
add_newdoc('scipy.special', 'kolmogi', '\n    y=kolmogi(p) returns y such that kolmogorov(y) = p\n    ')
add_newdoc('scipy.special', 'kolmogorov', "\n    p=kolmogorov(y) returns the complementary cumulative distribution\n    function of Kolmogorov's limiting distribution (Kn* for large n)\n    of a two-sided test for equality between an empirical and a theoretical\n    distribution. It is equal to the (limit as n->infinity of the) probability\n    that sqrt(n) * max absolute deviation > y.\n    ")
add_newdoc('scipy.special', 'kv', '\n    y=kv(v,z) returns the modified Bessel function of the second kind (sometimes called the third kind) for\n    real order v at complex z.\n    ')
add_newdoc('scipy.special', 'kve', '\n    y=kve(v,z) returns the exponentially scaled, modified Bessel function\n    of the second kind (sometimes called the third kind) for real order v at complex z: kve(v,z) = kv(v,z) * exp(z)\n    ')
add_newdoc('scipy.special', 'log1p', '\n    y=log1p(x) calculates log(1+x) for use when x is near zero.\n    ')
add_newdoc('scipy.special', 'logit', '\n    Logit ufunc for ndarrays.\n\n    The logit function is defined as logit(p) = log(p/(1-p)).\n    Note that logit(0) = -inf, logit(1) = inf, and logit(p)\n    for p<0 or p>1 yields nan.\n\n    Parameters\n    ----------\n    x : ndarray\n        The ndarray to apply logit to element-wise.\n\n    Returns\n    -------\n    out : ndarray\n        An ndarray of the same shape as x. Its entries\n        are logit of the corresponding entry of x.\n\n    Notes\n    -----\n    As a ufunc logit takes a number of optional\n    keywork arguments. For more information\n    see `ufuncs <http://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n    ')
add_newdoc('scipy.special', 'lpmv', '\n    y=lpmv(m,v,x) returns the associated legendre function of integer order\n    m and real degree v (s.t. v>-m-1 or v<m): ``|x| <= 1``.\n    ')
add_newdoc('scipy.special', 'mathieu_a', "\n    lmbda=mathieu_a(m,q) returns the characteristic value for the even solution,\n    ce_m(z,q), of Mathieu's equation\n    ")
add_newdoc('scipy.special', 'mathieu_b', "\n    lmbda=mathieu_b(m,q) returns the characteristic value for the odd solution,\n    se_m(z,q), of Mathieu's equation\n    ")
add_newdoc('scipy.special', 'mathieu_cem', '\n    (y,yp)=mathieu_cem(m,q,x) returns the even Mathieu function, ce_m(x,q),\n    of order m and parameter q evaluated at x (given in degrees).\n    Also returns the derivative with respect to x of ce_m(x,q)\n    ')
add_newdoc('scipy.special', 'mathieu_modcem1', '\n    (y,yp)=mathieu_modcem1(m,q,x) evaluates the even modified Mathieu function\n    of the first kind, Mc1m(x,q), and its derivative at x for order m and\n    parameter q.\n    ')
add_newdoc('scipy.special', 'mathieu_modcem2', '\n    (y,yp)=mathieu_modcem2(m,q,x) evaluates the even modified Mathieu function\n    of the second kind, Mc2m(x,q), and its derivative at x (given in degrees)\n    for order m and parameter q.\n    ')
add_newdoc('scipy.special', 'mathieu_modsem1', '\n    (y,yp)=mathieu_modsem1(m,q,x) evaluates the odd modified Mathieu function\n    of the first kind, Ms1m(x,q), and its derivative at x (given in degrees)\n    for order m and parameter q.\n    ')
add_newdoc('scipy.special', 'mathieu_modsem2', '\n    (y,yp)=mathieu_modsem2(m,q,x) evaluates the odd modified Mathieu function\n    of the second kind, Ms2m(x,q), and its derivative at x (given in degrees)\n    for order m and parameter q.\n    ')
add_newdoc('scipy.special', 'mathieu_sem', '\n    (y,yp)=mathieu_sem(m,q,x) returns the odd Mathieu function, se_m(x,q),\n    of order m and parameter q evaluated at x (given in degrees).\n    Also returns the derivative with respect to x of se_m(x,q).\n    ')
add_newdoc('scipy.special', 'modfresnelm', '\n    (fm,km)=modfresnelp(x) returns the modified Fresnel integrals ``F_-(x)`` and ``K_-(x)``\n    as ``fp=integral(exp(-1j*t*t),t=x..inf)`` and ``kp=1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp``\n    ')
add_newdoc('scipy.special', 'modfresnelp', '\n    (fp,kp)=modfresnelp(x) returns the modified Fresnel integrals F_+(x) and K_+(x)\n    as fp=integral(exp(1j*t*t),t=x..inf) and kp=1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp\n    ')
add_newdoc('scipy.special', 'modstruve', '\n    y=modstruve(v,x) returns the modified Struve function Lv(x) of order\n    v at x, x must be positive unless v is an integer and it is recommended\n    that ``|v| <= 20``.\n    ')
add_newdoc('scipy.special', 'nbdtr', '\n    y=nbdtr(k,n,p) returns the sum of the terms 0 through k of the\n    negative binomial distribution: sum((n+j-1)Cj p**n (1-p)**j,j=0..k).\n    In a sequence of Bernoulli trials this is the probability that k or\n    fewer failures precede the nth success.\n    ')
add_newdoc('scipy.special', 'nbdtrc', '\n    y=nbdtrc(k,n,p) returns the sum of the terms k+1 to infinity of the\n    negative binomial distribution.\n    ')
add_newdoc('scipy.special', 'nbdtri', '\n    p=nbdtri(k,n,y) finds the argument p such that nbdtr(k,n,p)=y.\n    ')
add_newdoc('scipy.special', 'nbdtrik', '\n    k=nbdtrik(y,n,p) finds the argument k such that nbdtr(k,n,p)=y.\n    ')
add_newdoc('scipy.special', 'nbdtrin', '\n    n=nbdtrin(k,y,p) finds the argument n such that nbdtr(k,n,p)=y.\n    ')
add_newdoc('scipy.special', 'ncfdtr', '\n    ')
add_newdoc('scipy.special', 'ncfdtri', '\n    ')
add_newdoc('scipy.special', 'ncfdtrifn', '\n    ')
add_newdoc('scipy.special', 'ncfdtridfd', '\n    ')
add_newdoc('scipy.special', 'ncfdtridfn', '\n    ')
add_newdoc('scipy.special', 'ncfdtrinc', '\n    ')
add_newdoc('scipy.special', 'nctdtr', '\n    ')
add_newdoc('scipy.special', 'nctdtridf', '\n    ')
add_newdoc('scipy.special', 'nctdtrinc', '\n    ')
add_newdoc('scipy.special', 'nctdtrit', '\n    ')
add_newdoc('scipy.special', 'ndtr', '\n    y=ndtr(x) returns the area under the standard Gaussian probability\n    density function, integrated from minus infinity to x:\n    1/sqrt(2*pi) * integral(exp(-t**2 / 2),t=-inf..x)\n    ')
add_newdoc('scipy.special', 'nrdtrimn', '\n    ')
add_newdoc('scipy.special', 'nrdtrisd', '\n    ')
add_newdoc('scipy.special', 'log_ndtr', '\n    y=log_ndtr(x) returns the log of the area under the standard Gaussian probability\n    density function, integrated from minus infinity to x:\n    1/sqrt(2*pi) * integral(exp(-t**2 / 2),t=-inf..x)\n    ')
add_newdoc('scipy.special', 'ndtri', '\n    x=ndtri(y) returns the argument x for which the area udnder the\n    Gaussian probability density function (integrated from minus infinity\n    to x) is equal to y.\n    ')
add_newdoc('scipy.special', 'obl_ang1', '\n    (s,sp)=obl_ang1(m,n,c,x) computes the oblate sheroidal angular function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``.\n    ')
add_newdoc('scipy.special', 'obl_ang1_cv', '\n    (s,sp)=obl_ang1_cv(m,n,c,cv,x) computes the oblate sheroidal angular function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``. Requires pre-computed\n    characteristic value.\n    ')
add_newdoc('scipy.special', 'obl_cv', '\n    cv=obl_cv(m,n,c) computes the characteristic value of oblate spheroidal\n    wave functions of order m,n (n>=m) and spheroidal parameter c.\n    ')
add_newdoc('scipy.special', 'obl_rad1', '\n    (s,sp)=obl_rad1(m,n,c,x) computes the oblate sheroidal radial function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``.\n    ')
add_newdoc('scipy.special', 'obl_rad1_cv', '\n    (s,sp)=obl_rad1_cv(m,n,c,cv,x) computes the oblate sheroidal radial function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``. Requires pre-computed\n    characteristic value.\n    ')
add_newdoc('scipy.special', 'obl_rad2', '\n    (s,sp)=obl_rad2(m,n,c,x) computes the oblate sheroidal radial function\n    of the second kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``.\n    ')
add_newdoc('scipy.special', 'obl_rad2_cv', '\n    (s,sp)=obl_rad2_cv(m,n,c,cv,x) computes the oblate sheroidal radial function\n    of the second kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``. Requires pre-computed\n    characteristic value.\n    ')
add_newdoc('scipy.special', 'pbdv', "\n    (d,dp)=pbdv(v,x) returns (d,dp) with the parabolic cylinder function Dv(x) in\n    d and the derivative, Dv'(x) in dp.\n    ")
add_newdoc('scipy.special', 'pbvv', "\n    (v,vp)=pbvv(v,x) returns (v,vp) with the parabolic cylinder function Vv(x) in\n    v and the derivative, Vv'(x) in vp.\n    ")
add_newdoc('scipy.special', 'pbwa', "\n    (w,wp)=pbwa(a,x) returns (w,wp) with the parabolic cylinder function W(a,x) in\n    w and the derivative, W'(a,x) in wp.  May not be accurate for large (>5)\n    arguments in a and/or x.\n    ")
add_newdoc('scipy.special', 'pdtr', '\n    y=pdtr(k,m) returns the sum of the first k terms of the Poisson\n    distribution: sum(exp(-m) * m**j / j!, j=0..k) = gammaincc( k+1, m).\n    Arguments must both be positive and k an integer.\n    ')
add_newdoc('scipy.special', 'pdtrc', '\n    y=pdtrc(k,m) returns the sum of the terms from k+1 to infinity of the\n    Poisson distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc( k+1, m).\n    Arguments must both be positive and k an integer.\n    ')
add_newdoc('scipy.special', 'pdtri', '\n    m=pdtri(k,y) returns the Poisson variable m such that the sum\n    from 0 to k of the Poisson density is equal to the given probability\n    y:  calculated by gammaincinv( k+1, y).  k must be a nonnegative integer and\n    y between 0 and 1.\n    ')
add_newdoc('scipy.special', 'pdtrik', '\n    k=pdtrik(p,m) returns the quantile k such that pdtr(k,m)=p\n    ')
add_newdoc('scipy.special', 'pro_ang1', '\n    (s,sp)=pro_ang1(m,n,c,x) computes the prolate sheroidal angular function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``.\n    ')
add_newdoc('scipy.special', 'pro_ang1_cv', '\n    (s,sp)=pro_ang1_cv(m,n,c,cv,x) computes the prolate sheroidal angular function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``. Requires pre-computed\n    characteristic value.\n    ')
add_newdoc('scipy.special', 'pro_cv', '\n    cv=pro_cv(m,n,c) computes the characteristic value of prolate spheroidal\n    wave functions of order m,n (n>=m) and spheroidal parameter c.\n    ')
add_newdoc('scipy.special', 'pro_rad1', '\n    (s,sp)=pro_rad1(m,n,c,x) computes the prolate sheroidal radial function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``.\n    ')
add_newdoc('scipy.special', 'pro_rad1_cv', '\n    (s,sp)=pro_rad1_cv(m,n,c,cv,x) computes the prolate sheroidal radial function\n    of the first kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``. Requires pre-computed\n    characteristic value.\n    ')
add_newdoc('scipy.special', 'pro_rad2', '\n    (s,sp)=pro_rad2(m,n,c,x) computes the prolate sheroidal radial function\n    of the second kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and |x|<1.0.\n    ')
add_newdoc('scipy.special', 'pro_rad2_cv', '\n    (s,sp)=pro_rad2_cv(m,n,c,cv,x) computes the prolate sheroidal radial function\n    of the second kind and its derivative (with respect to x) for mode parameters\n    m>=0 and n>=m, spheroidal parameter c and ``|x| < 1.0``. Requires pre-computed\n    characteristic value.\n    ')
add_newdoc('scipy.special', 'psi', '\n    y=psi(z) is the derivative of the logarithm of the gamma function\n    evaluated at z (also called the digamma function).\n    ')
add_newdoc('scipy.special', 'radian', '\n    y=radian(d,m,s) returns the angle given in (d)egrees, (m)inutes, and\n    (s)econds in radians.\n    ')
add_newdoc('scipy.special', 'rgamma', '\n    y=rgamma(z) returns one divided by the gamma function of x.\n    ')
add_newdoc('scipy.special', 'round', '\n    y=Returns the nearest integer to x as a double precision\n    floating point result.  If x ends in 0.5 exactly, the\n    nearest even integer is chosen.\n    ')
add_newdoc('scipy.special', 'shichi', "\n    (shi,chi)=shichi(x) returns the hyperbolic sine and cosine integrals:\n    integral(sinh(t)/t,t=0..x) and eul + ln x +\n    integral((cosh(t)-1)/t,t=0..x) where eul is Euler's Constant.\n    ")
add_newdoc('scipy.special', 'sici', '\n    (si,ci)=sici(x) returns in si the integral of the sinc function from 0 to x:\n    integral(sin(t)/t,t=0..x).  It returns in ci the cosine integral: eul + ln x +\n    integral((cos(t) - 1)/t,t=0..x).\n    ')
add_newdoc('scipy.special', 'sindg', '\n    y=sindg(x) calculates the sine of the angle x given in degrees.\n    ')
add_newdoc('scipy.special', 'smirnov', '\n    y=smirnov(n,e) returns the exact Kolmogorov-Smirnov complementary\n    cumulative distribution function (Dn+ or Dn-) for a one-sided test of\n    equality between an empirical and a theoretical distribution. It is equal\n    to the probability that the maximum difference between a theoretical\n    distribution and an empirical one based on n samples is greater than e.\n    ')
add_newdoc('scipy.special', 'smirnovi', '\n    e=smirnovi(n,y) returns e such that smirnov(n,e) = y.\n    ')
add_newdoc('scipy.special', 'spence', '\n    y=spence(x) returns the dilogarithm integral: -integral(log t /\n    (t-1),t=1..x)\n    ')
add_newdoc('scipy.special', 'stdtr', '\n    p=stdtr(df,t) returns the integral from minus infinity to t of the Student t\n    distribution with df > 0 degrees of freedom:\n    gamma((df+1)/2)/(sqrt(df*pi)*gamma(df/2)) * integral((1+x**2/df)**(-df/2-1/2),\n    x=-inf..t)\n    ')
add_newdoc('scipy.special', 'stdtridf', '\n    t=stdtridf(p,t) returns the argument df such that stdtr(df,t) is equal to p.\n    ')
add_newdoc('scipy.special', 'stdtrit', '\n    t=stdtrit(df,p) returns the argument t such that stdtr(df,t) is equal to p.\n    ')
add_newdoc('scipy.special', 'struve', '\n    y=struve(v,x) returns the Struve function Hv(x) of order v at x, x\n    must be positive unless v is an integer.\n    ')
add_newdoc('scipy.special', 'tandg', '\n    y=tandg(x) calculates the tangent of the angle x given in degrees.\n    ')
add_newdoc('scipy.special', 'tklmbda', '\n    ')
add_newdoc('scipy.special', 'wofz', '\n    y=wofz(z) returns the value of the fadeeva function for complex argument\n    z: exp(-z**2)*erfc(-i*z)\n\n    References\n    ----------\n    .. [1] Steven G. Johnson, Faddeeva W function implementation.\n       http://ab-initio.mit.edu/Faddeeva\n    ')
add_newdoc('scipy.special', 'y0', '\n    y=y0(x) returns the Bessel function of the second kind of order 0 at x.\n    ')
add_newdoc('scipy.special', 'y1', '\n    y=y1(x) returns the Bessel function of the second kind of order 1 at x.\n    ')
add_newdoc('scipy.special', 'yn', '\n    y=yn(n,x) returns the Bessel function of the second kind of integer\n    order n at x.\n    ')
add_newdoc('scipy.special', 'yv', '\n    y=yv(v,z) returns the Bessel function of the second kind of real\n    order v at complex z.\n    ')
add_newdoc('scipy.special', 'yve', '\n    y=yve(v,z) returns the exponentially scaled Bessel function of the second\n    kind of real order v at complex z: yve(v,z) = yv(v,z) * exp(-abs(z.imag))\n    ')
add_newdoc('scipy.special', 'zeta', '\n    y=zeta(x,q) returns the Riemann zeta function of two arguments:\n    sum((k+q)**(-x),k=0..inf)\n    ')
add_newdoc('scipy.special', 'zetac', '\n    y=zetac(x) returns 1.0 - the Riemann zeta function: sum(k**(-x), k=2..inf)\n    ')