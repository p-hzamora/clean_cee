# uncompyle6 version 3.9.0
# Python bytecode version base 2.7 (62211)
# Decompiled from: Python 3.10.9 | packaged by Anaconda, Inc. | (main, Mar  8 2023, 10:42:25) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: numpy\polynomial\polytemplate.pyc
# Compiled at: 2013-04-07 07:04:04
"""
Template for the Chebyshev and Polynomial classes.

This module houses a Python string module Template object (see, e.g.,
http://docs.python.org/library/string.html#template-strings) used by
the `polynomial` and `chebyshev` modules to implement their respective
`Polynomial` and `Chebyshev` classes.  It provides a mechanism for easily
creating additional specific polynomial classes (e.g., Legendre, Jacobi,
etc.) in the future, such that all these classes will have a common API.

"""
import string, sys
if sys.version_info[0] >= 3:
    rel_import = 'from . import'
else:
    rel_import = 'import'
polytemplate = string.Template(('\nfrom __future__ import division\nimport numpy as np\nimport warnings\nREL_IMPORT polyutils as pu\n\nclass $name(pu.PolyBase) :\n    """A $name series class.\n\n    $name instances provide the standard Python numerical methods \'+\',\n    \'-\', \'*\', \'//\', \'%\', \'divmod\', \'**\', and \'()\' as well as the listed\n    methods.\n\n    Parameters\n    ----------\n    coef : array_like\n        $name coefficients, in increasing order.  For example,\n        ``(1, 2, 3)`` implies ``P_0 + 2P_1 + 3P_2`` where the\n        ``P_i`` are a graded polynomial basis.\n    domain : (2,) array_like, optional\n        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped to\n        the interval ``[window[0], window[1]]`` by shifting and scaling.\n        The default value is $domain.\n    window : (2,) array_like, optional\n        Window, see ``domain`` for its use. The default value is $domain.\n        .. versionadded:: 1.6.0\n\n    Attributes\n    ----------\n    coef : (N,) ndarray\n        $name coefficients, from low to high.\n    domain : (2,) ndarray\n        Domain that is mapped to ``window``.\n    window : (2,) ndarray\n        Window that ``domain`` is mapped to.\n\n    Class Attributes\n    ----------------\n    maxpower : int\n        Maximum power allowed, i.e., the largest number ``n`` such that\n        ``p(x)**n`` is allowed. This is to limit runaway polynomial size.\n    domain : (2,) ndarray\n        Default domain of the class.\n    window : (2,) ndarray\n        Default window of the class.\n\n    Notes\n    -----\n    It is important to specify the domain in many cases, for instance in\n    fitting data, because many of the important properties of the\n    polynomial basis only hold in a specified interval and consequently\n    the data must be mapped into that interval in order to benefit.\n\n    Examples\n    --------\n\n    """\n    # Limit runaway size. T_n^m has degree n*2^m\n    maxpower = 16\n    # Default domain\n    domain = np.array($domain)\n    # Default window\n    window = np.array($domain)\n    # Don\'t let participate in array operations. Value doesn\'t matter.\n    __array_priority__ = 1000\n\n    def has_samecoef(self, other):\n        """Check if coefficients match.\n\n        Parameters\n        ----------\n        other : class instance\n            The other class must have the ``coef`` attribute.\n\n        Returns\n        -------\n        bool : boolean\n            True if the coefficients are the same, False otherwise.\n\n        Notes\n        -----\n        .. versionadded:: 1.6.0\n\n        """\n        if len(self.coef) != len(other.coef):\n            return False\n        elif not np.all(self.coef == other.coef):\n            return False\n        else:\n            return True\n\n    def has_samedomain(self, other):\n        """Check if domains match.\n\n        Parameters\n        ----------\n        other : class instance\n            The other class must have the ``domain`` attribute.\n\n        Returns\n        -------\n        bool : boolean\n            True if the domains are the same, False otherwise.\n\n        Notes\n        -----\n        .. versionadded:: 1.6.0\n\n        """\n        return np.all(self.domain == other.domain)\n\n    def has_samewindow(self, other):\n        """Check if windows match.\n\n        Parameters\n        ----------\n        other : class instance\n            The other class must have the ``window`` attribute.\n\n        Returns\n        -------\n        bool : boolean\n            True if the windows are the same, False otherwise.\n\n        Notes\n        -----\n        .. versionadded:: 1.6.0\n\n        """\n        return np.all(self.window == other.window)\n\n    def has_sametype(self, other):\n        """Check if types match.\n\n        Parameters\n        ----------\n        other : object\n            Class instance.\n\n        Returns\n        -------\n        bool : boolean\n            True if other is same class as self\n\n        Notes\n        -----\n        .. versionadded:: 1.7.0\n\n        """\n        return isinstance(other, self.__class__)\n\n    def __init__(self, coef, domain=$domain, window=$domain) :\n        [coef, dom, win] = pu.as_series([coef, domain, window], trim=False)\n        if len(dom) != 2 :\n            raise ValueError("Domain has wrong number of elements.")\n        if len(win) != 2 :\n            raise ValueError("Window has wrong number of elements.")\n        self.coef = coef\n        self.domain = dom\n        self.window = win\n\n    def __repr__(self):\n        format = "%s(%s, %s, %s)"\n        coef = repr(self.coef)[6:-1]\n        domain = repr(self.domain)[6:-1]\n        window = repr(self.window)[6:-1]\n        return format % (\'$name\', coef, domain, window)\n\n    def __str__(self) :\n        format = "%s(%s)"\n        coef = str(self.coef)\n        return format % (\'$nick\', coef)\n\n    # Pickle and copy\n\n    def __getstate__(self) :\n        ret = self.__dict__.copy()\n        ret[\'coef\'] = self.coef.copy()\n        ret[\'domain\'] = self.domain.copy()\n        ret[\'window\'] = self.window.copy()\n        return ret\n\n    def __setstate__(self, dict) :\n        self.__dict__ = dict\n\n    # Call\n\n    def __call__(self, arg) :\n        off, scl = pu.mapparms(self.domain, self.window)\n        arg = off + scl*arg\n        return ${nick}val(arg, self.coef)\n\n    def __iter__(self) :\n        return iter(self.coef)\n\n    def __len__(self) :\n        return len(self.coef)\n\n    # Numeric properties.\n\n    def __neg__(self) :\n        return self.__class__(-self.coef, self.domain, self.window)\n\n    def __pos__(self) :\n        return self\n\n    def __add__(self, other) :\n        """Returns sum"""\n        if isinstance(other, pu.PolyBase):\n            if not self.has_sametype(other):\n                raise TypeError("Polynomial types differ")\n            elif not self.has_samedomain(other):\n                raise TypeError("Domains differ")\n            elif not self.has_samewindow(other):\n                raise TypeError("Windows differ")\n            else:\n                coef = ${nick}add(self.coef, other.coef)\n        else :\n            try :\n                coef = ${nick}add(self.coef, other)\n            except :\n                return NotImplemented\n        return self.__class__(coef, self.domain, self.window)\n\n    def __sub__(self, other) :\n        """Returns difference"""\n        if isinstance(other, pu.PolyBase):\n            if not self.has_sametype(other):\n                raise TypeError("Polynomial types differ")\n            elif not self.has_samedomain(other):\n                raise TypeError("Domains differ")\n            elif not self.has_samewindow(other):\n                raise TypeError("Windows differ")\n            else:\n                coef = ${nick}sub(self.coef, other.coef)\n        else :\n            try :\n                coef = ${nick}sub(self.coef, other)\n            except :\n                return NotImplemented\n        return self.__class__(coef, self.domain, self.window)\n\n    def __mul__(self, other) :\n        """Returns product"""\n        if isinstance(other, pu.PolyBase):\n            if not self.has_sametype(other):\n                raise TypeError("Polynomial types differ")\n            elif not self.has_samedomain(other):\n                raise TypeError("Domains differ")\n            elif not self.has_samewindow(other):\n                raise TypeError("Windows differ")\n            else:\n                coef = ${nick}mul(self.coef, other.coef)\n        else :\n            try :\n                coef = ${nick}mul(self.coef, other)\n            except :\n                return NotImplemented\n        return self.__class__(coef, self.domain, self.window)\n\n    def __div__(self, other):\n        # set to __floordiv__,  /, for now.\n        return self.__floordiv__(other)\n\n    def __truediv__(self, other) :\n        # there is no true divide if the rhs is not a scalar, although it\n        # could return the first n elements of an infinite series.\n        # It is hard to see where n would come from, though.\n        if np.isscalar(other) :\n            # this might be overly restrictive\n            coef = self.coef/other\n            return self.__class__(coef, self.domain, self.window)\n        else :\n            return NotImplemented\n\n    def __floordiv__(self, other) :\n        """Returns the quotient."""\n        if isinstance(other, pu.PolyBase):\n            if not self.has_sametype(other):\n                raise TypeError("Polynomial types differ")\n            elif not self.has_samedomain(other):\n                raise TypeError("Domains differ")\n            elif not self.has_samewindow(other):\n                raise TypeError("Windows differ")\n            else:\n                quo, rem = ${nick}div(self.coef, other.coef)\n        else :\n            try :\n                quo, rem = ${nick}div(self.coef, other)\n            except :\n                return NotImplemented\n        return self.__class__(quo, self.domain, self.window)\n\n    def __mod__(self, other) :\n        """Returns the remainder."""\n        if isinstance(other, pu.PolyBase):\n            if not self.has_sametype(other):\n                raise TypeError("Polynomial types differ")\n            elif not self.has_samedomain(other):\n                raise TypeError("Domains differ")\n            elif not self.has_samewindow(other):\n                raise TypeError("Windows differ")\n            else:\n                quo, rem = ${nick}div(self.coef, other.coef)\n        else :\n            try :\n                quo, rem = ${nick}div(self.coef, other)\n            except :\n                return NotImplemented\n        return self.__class__(rem, self.domain, self.window)\n\n    def __divmod__(self, other) :\n        """Returns quo, remainder"""\n        if isinstance(other, self.__class__) :\n            if not self.has_samedomain(other):\n                raise TypeError("Domains are not equal")\n            elif not self.has_samewindow(other):\n                raise TypeError("Windows are not equal")\n            else:\n                quo, rem = ${nick}div(self.coef, other.coef)\n        else :\n            try :\n                quo, rem = ${nick}div(self.coef, other)\n            except :\n                return NotImplemented\n        quo = self.__class__(quo, self.domain, self.window)\n        rem = self.__class__(rem, self.domain, self.window)\n        return quo, rem\n\n    def __pow__(self, other) :\n        try :\n            coef = ${nick}pow(self.coef, other, maxpower = self.maxpower)\n        except :\n            raise\n        return self.__class__(coef, self.domain, self.window)\n\n    def __radd__(self, other) :\n        try :\n            coef = ${nick}add(other, self.coef)\n        except :\n            return NotImplemented\n        return self.__class__(coef, self.domain, self.window)\n\n    def __rsub__(self, other):\n        try :\n            coef = ${nick}sub(other, self.coef)\n        except :\n            return NotImplemented\n        return self.__class__(coef, self.domain, self.window)\n\n    def __rmul__(self, other) :\n        try :\n            coef = ${nick}mul(other, self.coef)\n        except :\n            return NotImplemented\n        return self.__class__(coef, self.domain, self.window)\n\n    def __rdiv__(self, other):\n        # set to __floordiv__ /.\n        return self.__rfloordiv__(other)\n\n    def __rtruediv__(self, other) :\n        # there is no true divide if the rhs is not a scalar, although it\n        # could return the first n elements of an infinite series.\n        # It is hard to see where n would come from, though.\n        if len(self.coef) == 1 :\n            try :\n                quo, rem = ${nick}div(other, self.coef[0])\n            except :\n                return NotImplemented\n        return self.__class__(quo, self.domain, self.window)\n\n    def __rfloordiv__(self, other) :\n        try :\n            quo, rem = ${nick}div(other, self.coef)\n        except :\n            return NotImplemented\n        return self.__class__(quo, self.domain, self.window)\n\n    def __rmod__(self, other) :\n        try :\n            quo, rem = ${nick}div(other, self.coef)\n        except :\n            return NotImplemented\n        return self.__class__(rem, self.domain, self.window)\n\n    def __rdivmod__(self, other) :\n        try :\n            quo, rem = ${nick}div(other, self.coef)\n        except :\n            return NotImplemented\n        quo = self.__class__(quo, self.domain, self.window)\n        rem = self.__class__(rem, self.domain, self.window)\n        return quo, rem\n\n    # Enhance me\n    # some augmented arithmetic operations could be added here\n\n    def __eq__(self, other) :\n        res = isinstance(other, self.__class__)                 and self.has_samecoef(other)                 and self.has_samedomain(other)                 and self.has_samewindow(other)\n        return res\n\n    def __ne__(self, other) :\n        return not self.__eq__(other)\n\n    #\n    # Extra methods.\n    #\n\n    def copy(self) :\n        """Return a copy.\n\n        Return a copy of the current $name instance.\n\n        Returns\n        -------\n        new_instance : $name\n            Copy of current instance.\n\n        """\n        return self.__class__(self.coef, self.domain, self.window)\n\n    def degree(self) :\n        """The degree of the series.\n\n        Notes\n        -----\n        .. versionadded:: 1.5.0\n\n        """\n        return len(self) - 1\n\n    def cutdeg(self, deg) :\n        """Truncate series to the given degree.\n\n        Reduce the degree of the $name series to `deg` by discarding the\n        high order terms. If `deg` is greater than the current degree a\n        copy of the current series is returned. This can be useful in least\n        squares where the coefficients of the high degree terms may be very\n        small.\n\n        Parameters\n        ----------\n        deg : non-negative int\n            The series is reduced to degree `deg` by discarding the high\n            order terms. The value of `deg` must be a non-negative integer.\n\n        Returns\n        -------\n        new_instance : $name\n            New instance of $name with reduced degree.\n\n        Notes\n        -----\n        .. versionadded:: 1.5.0\n\n        """\n        return self.truncate(deg + 1)\n\n    def trim(self, tol=0) :\n        """Remove small leading coefficients\n\n        Remove leading coefficients until a coefficient is reached whose\n        absolute value greater than `tol` or the beginning of the series is\n        reached. If all the coefficients would be removed the series is set to\n        ``[0]``. A new $name instance is returned with the new coefficients.\n        The current instance remains unchanged.\n\n        Parameters\n        ----------\n        tol : non-negative number.\n            All trailing coefficients less than `tol` will be removed.\n\n        Returns\n        -------\n        new_instance : $name\n            Contains the new set of coefficients.\n\n        """\n        coef = pu.trimcoef(self.coef, tol)\n        return self.__class__(coef, self.domain, self.window)\n\n    def truncate(self, size) :\n        """Truncate series to length `size`.\n\n        Reduce the $name series to length `size` by discarding the high\n        degree terms. The value of `size` must be a positive integer. This\n        can be useful in least squares where the coefficients of the\n        high degree terms may be very small.\n\n        Parameters\n        ----------\n        size : positive int\n            The series is reduced to length `size` by discarding the high\n            degree terms. The value of `size` must be a positive integer.\n\n        Returns\n        -------\n        new_instance : $name\n            New instance of $name with truncated coefficients.\n\n        """\n        isize = int(size)\n        if isize != size or isize < 1 :\n            raise ValueError("size must be a positive integer")\n        if isize >= len(self.coef) :\n            coef = self.coef\n        else :\n            coef = self.coef[:isize]\n        return self.__class__(coef, self.domain, self.window)\n\n    def convert(self, domain=None, kind=None, window=None) :\n        """Convert to different class and/or domain.\n\n        Parameters\n        ----------\n        domain : array_like, optional\n            The domain of the converted series. If the value is None,\n            the default domain of `kind` is used.\n        kind : class, optional\n            The polynomial series type class to which the current instance\n            should be converted. If kind is None, then the class of the\n            current instance is used.\n        window : array_like, optional\n            The window of the converted series. If the value is None,\n            the default window of `kind` is used.\n\n        Returns\n        -------\n        new_series_instance : `kind`\n            The returned class can be of different type than the current\n            instance and/or have a different domain.\n\n        Notes\n        -----\n        Conversion between domains and class types can result in\n        numerically ill defined series.\n\n        Examples\n        --------\n\n        """\n        if kind is None:\n            kind = $name\n        if domain is None:\n            domain = kind.domain\n        if window is None:\n            window = kind.window\n        return self(kind.identity(domain, window=window))\n\n    def mapparms(self) :\n        """Return the mapping parameters.\n\n        The returned values define a linear map ``off + scl*x`` that is\n        applied to the input arguments before the series is evaluated. The\n        map depends on the ``domain`` and ``window``; if the current\n        ``domain`` is equal to the ``window`` the resulting map is the\n        identity.  If the coefficients of the ``$name`` instance are to be\n        used by themselves outside this class, then the linear function\n        must be substituted for the ``x`` in the standard representation of\n        the base polynomials.\n\n        Returns\n        -------\n        off, scl : floats or complex\n            The mapping function is defined by ``off + scl*x``.\n\n        Notes\n        -----\n        If the current domain is the interval ``[l_1, r_1]`` and the window\n        is ``[l_2, r_2]``, then the linear mapping function ``L`` is\n        defined by the equations::\n\n            L(l_1) = l_2\n            L(r_1) = r_2\n\n        """\n        return pu.mapparms(self.domain, self.window)\n\n    def integ(self, m=1, k=[], lbnd=None) :\n        """Integrate.\n\n        Return an instance of $name that is the definite integral of the\n        current series. Refer to `${nick}int` for full documentation.\n\n        Parameters\n        ----------\n        m : non-negative int\n            The number of integrations to perform.\n        k : array_like\n            Integration constants. The first constant is applied to the\n            first integration, the second to the second, and so on. The\n            list of values must less than or equal to `m` in length and any\n            missing values are set to zero.\n        lbnd : Scalar\n            The lower bound of the definite integral.\n\n        Returns\n        -------\n        integral : $name\n            The integral of the series using the same domain.\n\n        See Also\n        --------\n        ${nick}int : similar function.\n        ${nick}der : similar function for derivative.\n\n        """\n        off, scl = self.mapparms()\n        if lbnd is None :\n            lbnd = 0\n        else :\n            lbnd = off + scl*lbnd\n        coef = ${nick}int(self.coef, m, k, lbnd, 1./scl)\n        return self.__class__(coef, self.domain, self.window)\n\n    def deriv(self, m=1):\n        """Differentiate.\n\n        Return an instance of $name that is the derivative of the current\n        series.  Refer to `${nick}der` for full documentation.\n\n        Parameters\n        ----------\n        m : non-negative int\n            The number of integrations to perform.\n\n        Returns\n        -------\n        derivative : $name\n            The derivative of the series using the same domain.\n\n        See Also\n        --------\n        ${nick}der : similar function.\n        ${nick}int : similar function for integration.\n\n        """\n        off, scl = self.mapparms()\n        coef = ${nick}der(self.coef, m, scl)\n        return self.__class__(coef, self.domain, self.window)\n\n    def roots(self) :\n        """Return list of roots.\n\n        Return ndarray of roots for this series. See `${nick}roots` for\n        full documentation. Note that the accuracy of the roots is likely to\n        decrease the further outside the domain they lie.\n\n        See Also\n        --------\n        ${nick}roots : similar function\n        ${nick}fromroots : function to go generate series from roots.\n\n        """\n        roots = ${nick}roots(self.coef)\n        return pu.mapdomain(roots, self.window, self.domain)\n\n    def linspace(self, n=100, domain=None):\n        """Return x,y values at equally spaced points in domain.\n\n        Returns x, y values at `n` linearly spaced points across domain.\n        Here y is the value of the polynomial at the points x. By default\n        the domain is the same as that of the $name instance.  This method\n        is intended mostly as a plotting aid.\n\n        Parameters\n        ----------\n        n : int, optional\n            Number of point pairs to return. The default value is 100.\n        domain : {None, array_like}\n            If not None, the specified domain is used instead of that of\n            the calling instance. It should be of the form ``[beg,end]``.\n            The default is None.\n\n        Returns\n        -------\n        x, y : ndarrays\n            ``x`` is equal to linspace(self.domain[0], self.domain[1], n)\n            ``y`` is the polynomial evaluated at ``x``.\n\n        .. versionadded:: 1.5.0\n\n        """\n        if domain is None:\n            domain = self.domain\n        x = np.linspace(domain[0], domain[1], n)\n        y = self(x)\n        return x, y\n\n\n\n    @staticmethod\n    def fit(x, y, deg, domain=None, rcond=None, full=False, w=None,\n        window=$domain):\n        """Least squares fit to data.\n\n        Return a `$name` instance that is the least squares fit to the data\n        `y` sampled at `x`. Unlike `${nick}fit`, the domain of the returned\n        instance can be specified and this will often result in a superior\n        fit with less chance of ill conditioning. Support for NA was added\n        in version 1.7.0. See `${nick}fit` for full documentation of the\n        implementation.\n\n        Parameters\n        ----------\n        x : array_like, shape (M,)\n            x-coordinates of the M sample points ``(x[i], y[i])``.\n        y : array_like, shape (M,) or (M, K)\n            y-coordinates of the sample points. Several data sets of sample\n            points sharing the same x-coordinates can be fitted at once by\n            passing in a 2D-array that contains one dataset per column.\n        deg : int\n            Degree of the fitting polynomial.\n        domain : {None, [beg, end], []}, optional\n            Domain to use for the returned $name instance. If ``None``,\n            then a minimal domain that covers the points `x` is chosen.  If\n            ``[]`` the default domain ``$domain`` is used. The default\n            value is $domain in numpy 1.4.x and ``None`` in later versions.\n            The ``\'[]`` value was added in numpy 1.5.0.\n        rcond : float, optional\n            Relative condition number of the fit. Singular values smaller\n            than this relative to the largest singular value will be\n            ignored. The default value is len(x)*eps, where eps is the\n            relative precision of the float type, about 2e-16 in most\n            cases.\n        full : bool, optional\n            Switch determining nature of return value. When it is False\n            (the default) just the coefficients are returned, when True\n            diagnostic information from the singular value decomposition is\n            also returned.\n        w : array_like, shape (M,), optional\n            Weights. If not None the contribution of each point\n            ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the\n            weights are chosen so that the errors of the products\n            ``w[i]*y[i]`` all have the same variance.  The default value is\n            None.\n            .. versionadded:: 1.5.0\n        window : {[beg, end]}, optional\n            Window to use for the returned $name instance. The default\n            value is ``$domain``\n            .. versionadded:: 1.6.0\n\n        Returns\n        -------\n        least_squares_fit : instance of $name\n            The $name instance is the least squares fit to the data and\n            has the domain specified in the call.\n\n        [residuals, rank, singular_values, rcond] : only if `full` = True\n            Residuals of the least squares fit, the effective rank of the\n            scaled Vandermonde matrix and its singular values, and the\n            specified value of `rcond`. For more details, see\n            `linalg.lstsq`.\n\n        See Also\n        --------\n        ${nick}fit : similar function\n\n        """\n        if domain is None:\n            domain = pu.getdomain(x)\n        elif domain == []:\n            domain = $domain\n\n        if window == []:\n            window = $domain\n\n        xnew = pu.mapdomain(x, domain, window)\n        res = ${nick}fit(xnew, y, deg, w=w, rcond=rcond, full=full)\n        if full :\n            [coef, status] = res\n            return $name(coef, domain=domain, window=window), status\n        else :\n            coef = res\n            return $name(coef, domain=domain, window=window)\n\n    @staticmethod\n    def fromroots(roots, domain=$domain, window=$domain) :\n        """Return $name instance with specified roots.\n\n        Returns an instance of $name representing the product\n        ``(x - r[0])*(x - r[1])*...*(x - r[n-1])``, where ``r`` is the\n        list of roots.\n\n        Parameters\n        ----------\n        roots : array_like\n            List of roots.\n\n        Returns\n        -------\n        object : $name instance\n            Series with the specified roots.\n\n        See Also\n        --------\n        ${nick}fromroots : equivalent function\n\n        """\n        if domain is None :\n            domain = pu.getdomain(roots)\n        rnew = pu.mapdomain(roots, domain, window)\n        coef = ${nick}fromroots(rnew)\n        return $name(coef, domain=domain, window=window)\n\n    @staticmethod\n    def identity(domain=$domain, window=$domain) :\n        """Identity function.\n\n        If ``p`` is the returned $name object, then ``p(x) == x`` for all\n        values of x.\n\n        Parameters\n        ----------\n        domain : array_like\n            The resulting array must be of the form ``[beg, end]``, where\n            ``beg`` and ``end`` are the endpoints of the domain.\n        window : array_like\n            The resulting array must be if the form ``[beg, end]``, where\n            ``beg`` and ``end`` are the endpoints of the window.\n\n        Returns\n        -------\n        identity : $name instance\n\n        """\n        off, scl = pu.mapparms(window, domain)\n        coef = ${nick}line(off, scl)\n        return $name(coef, domain, window)\n\n    @staticmethod\n    def basis(deg, domain=$domain, window=$domain):\n        """$name polynomial of degree `deg`.\n\n        Returns an instance of the $name polynomial of degree `d`.\n\n        Parameters\n        ----------\n        deg : int\n            Degree of the $name polynomial. Must be >= 0.\n        domain : array_like\n            The resulting array must be of the form ``[beg, end]``, where\n            ``beg`` and ``end`` are the endpoints of the domain.\n        window : array_like\n            The resulting array must be if the form ``[beg, end]``, where\n            ``beg`` and ``end`` are the endpoints of the window.\n\n        Returns\n        p : $name instance\n\n        Notes\n        -----\n        .. versionadded:: 1.7.0\n\n        """\n        ideg = int(deg)\n        if ideg != deg or ideg < 0:\n            raise ValueError("deg must be non-negative integer")\n        return $name([0]*ideg + [1], domain, window)\n\n    @staticmethod\n    def cast(series, domain=$domain, window=$domain):\n        """Convert instance to equivalent $name series.\n\n        The `series` is expected to be an instance of some polynomial\n        series of one of the types supported by by the numpy.polynomial\n        module, but could be some other class that supports the convert\n        method.\n\n        Parameters\n        ----------\n        series : series\n            The instance series to be converted.\n        domain : array_like\n            The resulting array must be of the form ``[beg, end]``, where\n            ``beg`` and ``end`` are the endpoints of the domain.\n        window : array_like\n            The resulting array must be if the form ``[beg, end]``, where\n            ``beg`` and ``end`` are the endpoints of the window.\n\n        Returns\n        p : $name instance\n            A $name series equal to the `poly` series.\n\n        See Also\n        --------\n        convert -- similar instance method\n\n        Notes\n        -----\n        .. versionadded:: 1.7.0\n\n        """\n        return series.convert(domain, $name, window)\n\n').replace('REL_IMPORT', rel_import))