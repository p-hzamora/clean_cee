# uncompyle6 version 3.9.0
# Python bytecode version base 2.7 (62211)
# Decompiled from: Python 3.10.9 | packaged by Anaconda, Inc. | (main, Mar  8 2023, 10:42:25) [MSC v.1916 64 bit (AMD64)]
# Embedded file name: scipy\weave\swigptr2.pyc
# Compiled at: 2013-03-29 22:51:36
from __future__ import absolute_import, print_function
swigptr2_code_v0 = '\n\n#include "Python.h"\n\n/*************************************************************** -*- c -*-\n * python/precommon.swg\n *\n * Rename all exported symbols from common.swg, to avoid symbol\n * clashes if multiple interpreters are included\n *\n ************************************************************************/\n\n#define SWIG_TypeCheck       SWIG_Python_TypeCheck\n#define SWIG_TypeCast        SWIG_Python_TypeCast\n#define SWIG_TypeName        SWIG_Python_TypeName\n#define SWIG_TypeQuery       SWIG_Python_TypeQuery\n#define SWIG_PackData        SWIG_Python_PackData\n#define SWIG_UnpackData      SWIG_Python_UnpackData\n\n\n/***********************************************************************\n * common.swg\n *\n *     This file contains generic SWIG runtime support for pointer\n *     type checking as well as a few commonly used macros to control\n *     external linkage.\n *\n * Author : David Beazley (beazley@cs.uchicago.edu)\n *\n * Copyright (c) 1999-2000, The University of Chicago\n *\n * This file may be freely redistributed without license or fee provided\n * this copyright message remains intact.\n ************************************************************************/\n\n#include <string.h>\n\n#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n#  if defined(_MSC_VER) || defined(__GNUC__)\n#    if defined(STATIC_LINKED)\n#      define SWIGEXPORT(a) a\n#      define SWIGIMPORT(a) extern a\n#    else\n#      define SWIGEXPORT(a) __declspec(dllexport) a\n#      define SWIGIMPORT(a) extern a\n#    endif\n#  else\n#    if defined(__BORLANDC__)\n#      define SWIGEXPORT(a) a _export\n#      define SWIGIMPORT(a) a _export\n#    else\n#      define SWIGEXPORT(a) a\n#      define SWIGIMPORT(a) a\n#    endif\n#  endif\n#else\n#  define SWIGEXPORT(a) a\n#  define SWIGIMPORT(a) a\n#endif\n\n#ifdef SWIG_GLOBAL\n#  define SWIGRUNTIME(a) SWIGEXPORT(a)\n#else\n#  define SWIGRUNTIME(a) static a\n#endif\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\ntypedef void *(*swig_converter_func)(void *);\ntypedef struct swig_type_info *(*swig_dycast_func)(void **);\n\ntypedef struct swig_type_info {\n  const char             *name;\n  swig_converter_func     converter;\n  const char             *str;\n  void                   *clientdata;\n  swig_dycast_func        dcast;\n  struct swig_type_info  *next;\n  struct swig_type_info  *prev;\n} swig_type_info;\n\n#ifdef SWIG_NOINCLUDE\n\nSWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);\nSWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);\nSWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);\nSWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);\nSWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);\nSWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);\n\n#else\n\nstatic swig_type_info *swig_type_list = 0;\n\n/* Check the typename */\nSWIGRUNTIME(swig_type_info *)\nSWIG_TypeCheck(char *c, swig_type_info *ty) {\n  swig_type_info *s;\n  if (!ty) return 0;        /* Void pointer */\n  s = ty->next;             /* First element always just a name */\n  do {\n    if (strcmp(s->name,c) == 0) {\n      if (s == ty->next) return s;\n      /* Move s to the top of the linked list */\n      s->prev->next = s->next;\n      if (s->next) {\n        s->next->prev = s->prev;\n      }\n      /* Insert s as second element in the list */\n      s->next = ty->next;\n      if (ty->next) ty->next->prev = s;\n      ty->next = s;\n      s->prev = ty;\n      return s;\n    }\n    s = s->next;\n  } while (s && (s != ty->next));\n  return 0;\n}\n\n/* Cast a pointer up an inheritance hierarchy */\nSWIGRUNTIME(void *)\nSWIG_TypeCast(swig_type_info *ty, void *ptr) {\n  if ((!ty) || (!ty->converter)) return ptr;\n  return (*ty->converter)(ptr);\n}\n\n/* Return the name associated with this type */\nSWIGRUNTIME(const char *)\nSWIG_TypeName(const swig_type_info *ty) {\n  return ty->name;\n}\n\n/*\n   Compare two type names skipping the space characters, therefore\n   "char*" == "char *" and "Class<int>" == "Class<int >", etc.\n\n   Return 0 when the two name types are equivalent, as in\n   strncmp, but skipping \' \'.\n*/\nstatic int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n                  const char *f2, const char *l2) {\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == \' \') && (f1 != l1)) ++f1;\n    while ((*f2 == \' \') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return *f1 - *f2;\n  }\n  return (l1 - f1) - (l2 - f2);\n}\n\n/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n*/\nstatic int\nSWIG_TypeEquiv(const char *nb, const char *tb) {\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == \'|\') break;\n    }\n    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}\n\n\n/* Search for a swig_type_info structure */\nSWIGRUNTIME(swig_type_info *)\nSWIG_TypeQuery(const char *name) {\n  swig_type_info *ty = swig_type_list;\n  while (ty) {\n    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;\n    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;\n    ty = ty->prev;\n  }\n  return 0;\n}\n\n/* Pack binary data into a string */\nSWIGRUNTIME(char *)\nSWIG_PackData(char *c, void *ptr, int sz) {\n  static char hex[17] = "0123456789abcdef";\n  int i;\n  unsigned char *u = (unsigned char *) ptr;\n  register unsigned char uu;\n  for (i = 0; i < sz; i++,u++) {\n    uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}\n\n/* Unpack binary data from a string */\nSWIGRUNTIME(char *)\nSWIG_UnpackData(char *c, void *ptr, int sz) {\n  register unsigned char uu = 0;\n  register int d;\n  unsigned char *u = (unsigned char *) ptr;\n  int i;\n  for (i = 0; i < sz; i++, u++) {\n    d = *(c++);\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu = ((d - \'0\') << 4);\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu = ((d - (\'a\'-10)) << 4);\n    d = *(c++);\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu |= (d - \'0\');\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu |= (d - (\'a\'-10));\n    *u = uu;\n  }\n  return c;\n}\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n/***********************************************************************\n * python.swg\n *\n *     This file contains the runtime support for Python modules\n *     and includes code for managing global variables and pointer\n *     type checking.\n *\n * Author : David Beazley (beazley@cs.uchicago.edu)\n ************************************************************************/\n\n#include "Python.h"\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n#define SWIG_PY_INT     1\n#define SWIG_PY_FLOAT   2\n#define SWIG_PY_STRING  3\n#define SWIG_PY_POINTER 4\n#define SWIG_PY_BINARY  5\n\n/* Flags for pointer conversion */\n\n#define SWIG_POINTER_EXCEPTION     0x1\n#define SWIG_POINTER_DISOWN        0x2\n\n/* Exception handling in wrappers */\n#define SWIG_fail   goto fail\n\n/* Constant information structure */\ntypedef struct swig_const_info {\n    int type;\n    char *name;\n    long lvalue;\n    double dvalue;\n    void   *pvalue;\n    swig_type_info **ptype;\n} swig_const_info;\n\n/* Common SWIG API */\n#define SWIG_ConvertPtr(obj, pp, type, flags)   SWIG_Python_ConvertPtr(obj, pp, type, flags)\n#define SWIG_NewPointerObj(p, type, flags)   SWIG_Python_NewPointerObj(p, type, flags)\n#define SWIG_MustGetPtr(p, type, argnum, flags)   SWIG_Python_MustGetPtr(p, type, argnum, flags)\n\n\ntypedef double (*py_objasdbl_conv)(PyObject *obj);\n\n#ifdef SWIG_NOINCLUDE\n\nSWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);\nSWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);\nSWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);\n\n#else\n\n\n/* Convert a pointer value */\nSWIGRUNTIME(int)\nSWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {\n  swig_type_info *tc;\n  char  *c = 0;\n  static PyObject *SWIG_this = 0;\n  int    newref = 0;\n  PyObject  *pyobj = 0;\n\n  if (!obj) return 0;\n  if (obj == Py_None) {\n    *ptr = 0;\n    return 0;\n  }\n#ifdef SWIG_COBJECT_TYPES\n  if (!(PyCObject_Check(obj))) {\n    if (!SWIG_this)\n      SWIG_this = PyString_FromString("this");\n    pyobj = obj;\n    obj = PyObject_GetAttr(obj,SWIG_this);\n    newref = 1;\n    if (!obj) goto type_error;\n    if (!PyCObject_Check(obj)) {\n      Py_DECREF(obj);\n      goto type_error;\n    }\n  }\n  *ptr = PyCObject_AsVoidPtr(obj);\n  c = (char *) PyCObject_GetDesc(obj);\n  if (newref) Py_DECREF(obj);\n  goto cobject;\n#else\n  if (!(PyString_Check(obj))) {\n    if (!SWIG_this)\n      SWIG_this = PyString_FromString("this");\n    pyobj = obj;\n    obj = PyObject_GetAttr(obj,SWIG_this);\n    newref = 1;\n    if (!obj) goto type_error;\n    if (!PyString_Check(obj)) {\n      Py_DECREF(obj);\n      goto type_error;\n    }\n  }\n  c = PyString_AsString(obj);\n  /* Pointer values must start with leading underscore */\n  if (*c != \'_\') {\n    *ptr = (void *) 0;\n    if (strcmp(c,"NULL") == 0) {\n      if (newref) { Py_DECREF(obj); }\n      return 0;\n    } else {\n      if (newref) { Py_DECREF(obj); }\n      goto type_error;\n    }\n  }\n  c++;\n  c = SWIG_UnpackData(c,ptr,sizeof(void *));\n  if (newref) { Py_DECREF(obj); }\n#endif\n\n#ifdef SWIG_COBJECT_TYPES\ncobject:\n#endif\n\n  if (ty) {\n    tc = SWIG_TypeCheck(c,ty);\n    if (!tc) goto type_error;\n    *ptr = SWIG_TypeCast(tc,(void*) *ptr);\n  }\n\n  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {\n    PyObject *zero = PyInt_FromLong(0);\n    PyObject_SetAttrString(pyobj,(char*)"thisown",zero);\n    Py_DECREF(zero);\n  }\n  return 0;\n\ntype_error:\n  PyErr_Clear();\n  if (flags & SWIG_POINTER_EXCEPTION) {\n    if (ty && c) {\n      PyErr_Format(PyExc_TypeError,\n                   "Type error. Got %s, expected %s",\n                   c, ty->name);\n    } else {\n      PyErr_SetString(PyExc_TypeError,"Expected a pointer");\n    }\n  }\n  return -1;\n}\n\n/* Convert a pointer value, signal an exception on a type mismatch */\nSWIGRUNTIME(void *)\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {\n  void *result;\n  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);\n  return result;\n}\n\n/* Create a new pointer object */\nSWIGRUNTIME(PyObject *)\nSWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {\n  PyObject *robj;\n  if (!ptr) {\n    Py_INCREF(Py_None);\n    return Py_None;\n  }\n#ifdef SWIG_COBJECT_TYPES\n  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);\n#else\n  {\n    char result[1024];\n    char *r = result;\n    *(r++) = \'_\';\n    r = SWIG_PackData(r,&ptr,sizeof(void *));\n    strcpy(r,type->name);\n    robj = PyString_FromString(result);\n  }\n#endif\n  if (!robj || (robj == Py_None)) return robj;\n  if (type->clientdata) {\n    PyObject *inst;\n    PyObject *args = Py_BuildValue((char*)"(O)", robj);\n    Py_DECREF(robj);\n    inst = PyObject_CallObject((PyObject *) type->clientdata, args);\n    Py_DECREF(args);\n    if (inst) {\n      if (own) {\n        PyObject *n = PyInt_FromLong(1);\n        PyObject_SetAttrString(inst,(char*)"thisown",n);\n        Py_DECREF(n);\n      }\n      robj = inst;\n    }\n  }\n  return robj;\n}\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n'
swigptr2_code_v1 = '\n/***********************************************************************\n * swigrun.swg\n *\n *     This file contains generic CAPI SWIG runtime support for pointer\n *     type checking.\n *\n ************************************************************************/\n\n/* This should only be incremented when either the layout of swig_type_info changes,\n   or for whatever reason, the runtime changes incompatibly */\n#define SWIG_RUNTIME_VERSION "1"\n\n/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */\n#ifdef SWIG_TYPE_TABLE\n#define SWIG_QUOTE_STRING(x) #x\n#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)\n#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)\n#else\n#define SWIG_TYPE_TABLE_NAME\n#endif\n\n#include <string.h>\n\n#ifndef SWIGINLINE\n#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))\n#  define SWIGINLINE inline\n#else\n#  define SWIGINLINE\n#endif\n#endif\n\n/*\n  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for\n  creating a static or dynamic library from the swig runtime code.\n  In 99.9% of the cases, swig just needs to declare them as \'static\'.\n\n  But only do this if is strictly necessary, ie, if you have problems\n  with your compiler or so.\n*/\n#ifndef SWIGRUNTIME\n#define SWIGRUNTIME static\n#endif\n#ifndef SWIGRUNTIMEINLINE\n#define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE\n#endif\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\ntypedef void *(*swig_converter_func)(void *);\ntypedef struct swig_type_info *(*swig_dycast_func)(void **);\n\ntypedef struct swig_type_info {\n  const char             *name;\n  swig_converter_func     converter;\n  const char             *str;\n  void                   *clientdata;\n  swig_dycast_func        dcast;\n  struct swig_type_info  *next;\n  struct swig_type_info  *prev;\n} swig_type_info;\n\n/*\n  Compare two type names skipping the space characters, therefore\n  "char*" == "char *" and "Class<int>" == "Class<int >", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping \' \'.\n*/\nSWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n                  const char *f2, const char *l2) {\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == \' \') && (f1 != l1)) ++f1;\n    while ((*f2 == \' \') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return *f1 - *f2;\n  }\n  return (l1 - f1) - (l2 - f2);\n}\n\n/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n*/\nSWIGRUNTIME int\nSWIG_TypeEquiv(const char *nb, const char *tb) {\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == \'|\') break;\n    }\n    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}\n\n/*\n  Register a type mapping with the type-checking\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeRegisterTL(swig_type_info **tl, swig_type_info *ti) {\n  swig_type_info *tc, *head, *ret, *next;\n  /* Check to see if this type has already been registered */\n  tc = *tl;\n  while (tc) {\n    /* check simple type equivalence */\n    int typeequiv = (strcmp(tc->name, ti->name) == 0);\n    /* check full type equivalence, resolving typedefs */\n    if (!typeequiv) {\n      /* only if tc is not a typedef (no \'|\' on it) */\n      if (tc->str && ti->str && !strstr(tc->str,"|")) {\n        typeequiv = SWIG_TypeEquiv(ti->str,tc->str);\n      }\n    }\n    if (typeequiv) {\n      /* Already exists in the table.  Just add additional types to the list */\n      if (ti->clientdata) tc->clientdata = ti->clientdata;\n      head = tc;\n      next = tc->next;\n      goto l1;\n    }\n    tc = tc->prev;\n  }\n  head = ti;\n  next = 0;\n\n  /* Place in list */\n  ti->prev = *tl;\n  *tl = ti;\n\n  /* Build linked lists */\n  l1:\n  ret = head;\n  tc = ti + 1;\n  /* Patch up the rest of the links */\n  while (tc->name) {\n    head->next = tc;\n    tc->prev = head;\n    head = tc;\n    tc++;\n  }\n  if (next) next->prev = head;\n  head->next = next;\n\n  return ret;\n}\n\n/*\n  Check the typename\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeCheck(const char *c, swig_type_info *ty) {\n  swig_type_info *s;\n  if (!ty) return 0;        /* Void pointer */\n  s = ty->next;             /* First element always just a name */\n  do {\n    if (strcmp(s->name,c) == 0) {\n      if (s == ty->next) return s;\n      /* Move s to the top of the linked list */\n      s->prev->next = s->next;\n      if (s->next) {\n        s->next->prev = s->prev;\n      }\n      /* Insert s as second element in the list */\n      s->next = ty->next;\n      if (ty->next) ty->next->prev = s;\n      ty->next = s;\n      s->prev = ty;\n      return s;\n    }\n    s = s->next;\n  } while (s && (s != ty->next));\n  return 0;\n}\n\n/*\n  Cast a pointer up an inheritance hierarchy\n*/\nSWIGRUNTIMEINLINE void *\nSWIG_TypeCast(swig_type_info *ty, void *ptr) {\n  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);\n}\n\n/*\n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}\n\n/*\n  Return the name associated with this type\n*/\nSWIGRUNTIMEINLINE const char *\nSWIG_TypeName(const swig_type_info *ty) {\n  return ty->name;\n}\n\n/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\nSWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type) {\n  /* The "str" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == \'|\') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}\n\n/*\n  Search for a swig_type_info structure\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeQueryTL(swig_type_info *tl, const char *name) {\n  swig_type_info *ty = tl;\n  while (ty) {\n    if (ty->str && (SWIG_TypeEquiv(ty->str,name))) return ty;\n    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;\n    ty = ty->prev;\n  }\n  return 0;\n}\n\n/*\n   Set the clientdata field for a type\n*/\nSWIGRUNTIME void\nSWIG_TypeClientDataTL(swig_type_info *tl, swig_type_info *ti, void *clientdata) {\n  swig_type_info *tc, *equiv;\n  if (ti->clientdata) return;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n  equiv = ti->next;\n  while (equiv) {\n    if (!equiv->converter) {\n      tc = tl;\n      while (tc) {\n        if ((strcmp(tc->name, equiv->name) == 0))\n          SWIG_TypeClientDataTL(tl,tc,clientdata);\n        tc = tc->prev;\n      }\n    }\n    equiv = equiv->next;\n  }\n}\n\n/*\n   Pack binary data into a string\n*/\nSWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz) {\n  static char hex[17] = "0123456789abcdef";\n  unsigned char *u = (unsigned char *) ptr;\n  const unsigned char *eu =  u + sz;\n  register unsigned char uu;\n  for (; u != eu; ++u) {\n    uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}\n\n/*\n   Unpack binary data from a string\n*/\nSWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz) {\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register int d = *(c++);\n    register unsigned char uu = 0;\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu = ((d - \'0\') << 4);\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu = ((d - (\'a\'-10)) << 4);\n    else\n      return (char *) 0;\n    d = *(c++);\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu |= (d - \'0\');\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu |= (d - (\'a\'-10));\n    else\n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}\n\n/*\n  This function will propagate the clientdata field of type to any new\n  swig_type_info structures that have been added into the list of\n  equivalent types.  It is like calling SWIG_TypeClientData(type,\n  clientdata) a second time.\n*/\nSWIGRUNTIME void\nSWIG_PropagateClientDataTL(swig_type_info *tl, swig_type_info *type) {\n  swig_type_info *equiv = type->next;\n  swig_type_info *tc;\n  if (!type->clientdata) return;\n  while (equiv) {\n    if (!equiv->converter) {\n      tc = tl;\n      while (tc) {\n        if ((strcmp(tc->name, equiv->name) == 0) && !tc->clientdata)\n          SWIG_TypeClientDataTL(tl,tc, type->clientdata);\n        tc = tc->prev;\n      }\n    }\n    equiv = equiv->next;\n  }\n}\n\n/*\n   Pack \'void *\' into a string buffer.\n*/\nSWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = \'_\';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}\n\nSWIGRUNTIME const char *\nSWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {\n  if (*c != \'_\') {\n    if (strcmp(c,"NULL") == 0) {\n      *ptr = (void *) 0;\n      return name;\n    } else {\n      return 0;\n    }\n  }\n  return SWIG_UnpackData(++c,ptr,sizeof(void *));\n}\n\nSWIGRUNTIME char *\nSWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {\n  char *r = buff;\n  size_t lname = (name ? strlen(name) : 0);\n  if ((2*sz + 2 + lname) > bsz) return 0;\n  *(r++) = \'_\';\n  r = SWIG_PackData(r,ptr,sz);\n  if (lname) {\n    strncpy(r,name,lname+1);\n  } else {\n    *r = 0;\n  }\n  return buff;\n}\n\nSWIGRUNTIME const char *\nSWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {\n  if (*c != \'_\') {\n    if (strcmp(c,"NULL") == 0) {\n      memset(ptr,0,sz);\n      return name;\n    } else {\n      return 0;\n    }\n  }\n  return SWIG_UnpackData(++c,ptr,sz);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/***********************************************************************\n * pyrun.swg\n *\n *     This file contains the runtime support for Python modules\n *     and includes code for managing global variables and pointer\n *     type checking.\n *\n * Author : David Beazley (beazley@cs.uchicago.edu)\n ************************************************************************/\n\n/* Common SWIG API */\n#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)\n#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)\n#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)\n\n\n/* Python-specific SWIG API */\n#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)\n#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)\n\n\n/* -----------------------------------------------------------------------------\n * Pointer declarations\n * ----------------------------------------------------------------------------- */\n/*\n  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent\n  C/C++ pointers in the python side. Very useful for debugging, but\n  not always safe.\n*/\n#if !defined(SWIG_NO_COBJECT_TYPES) && !defined(SWIG_COBJECT_TYPES)\n#  define SWIG_COBJECT_TYPES\n#endif\n\n/* Flags for pointer conversion */\n#define SWIG_POINTER_EXCEPTION     0x1\n#define SWIG_POINTER_DISOWN        0x2\n\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* -----------------------------------------------------------------------------\n * Create a new pointer string\n * ----------------------------------------------------------------------------- */\n\n#ifndef SWIG_BUFFER_SIZE\n#define SWIG_BUFFER_SIZE 1024\n#endif\n\n#if defined(SWIG_COBJECT_TYPES)\n#if !defined(SWIG_COBJECT_PYTHON)\n/* -----------------------------------------------------------------------------\n * Implements a simple Swig Object type, and use it instead of PyCObject\n * ----------------------------------------------------------------------------- */\n\ntypedef struct {\n  PyObject_HEAD\n  void *ptr;\n  const char *desc;\n} PySwigObject;\n\n/* Declarations for objects of type PySwigObject */\n\nSWIGRUNTIME int\nPySwigObject_print(PySwigObject *v, FILE *fp, int flags)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result))) {\n    fputs("<Swig Object at ", fp); fputs(result, fp); fputs(">", fp);\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_repr(PySwigObject *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?\n    PyString_FromFormat("<Swig Object at %s>", result) : 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_str(PySwigObject *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?\n    PyString_FromString(result) : 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_long(PySwigObject *v)\n{\n  return PyLong_FromUnsignedLong((unsigned long) v->ptr);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_oct(PySwigObject *v)\n{\n  char buf[100];\n  unsigned long x = (unsigned long)v->ptr;\n  if (x == 0)\n    strcpy(buf, "0");\n  else\n    PyOS_snprintf(buf, sizeof(buf), "0%lo", x);\n  return PyString_FromString(buf);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_hex(PySwigObject *v)\n{\n  char buf[100];\n  PyOS_snprintf(buf, sizeof(buf), "0x%lx", (unsigned long)v->ptr);\n  return PyString_FromString(buf);\n}\n\nSWIGRUNTIME int\nPySwigObject_compare(PySwigObject *v, PySwigObject *w)\n{\n  int c = strcmp(v->desc, w->desc);\n  if (c) {\n    return c;\n  } else {\n    void *i = v->ptr;\n    void *j = w->ptr;\n    return (i < j) ? -1 : (i > j) ? 1 : 0;\n  }\n}\n\nSWIGRUNTIME void\nPySwigObject_dealloc(PySwigObject *self)\n{\n  PyObject_DEL(self);\n}\n\nSWIGRUNTIME PyTypeObject*\nPySwigObject_GetType() {\n  static char PySwigObject_Type__doc__[] =\n    "Swig object carries a C/C++ instance pointer";\n\n  static PyNumberMethods PySwigObject_as_number = {\n    (binaryfunc)0, /*nb_add*/\n    (binaryfunc)0, /*nb_subtract*/\n    (binaryfunc)0, /*nb_multiply*/\n    (binaryfunc)0, /*nb_divide*/\n    (binaryfunc)0, /*nb_remainder*/\n    (binaryfunc)0, /*nb_divmod*/\n    (ternaryfunc)0,/*nb_power*/\n    (unaryfunc)0,  /*nb_negative*/\n    (unaryfunc)0,  /*nb_positive*/\n    (unaryfunc)0,  /*nb_absolute*/\n    (inquiry)0,    /*nb_nonzero*/\n    0,             /*nb_invert*/\n    0,             /*nb_lshift*/\n    0,             /*nb_rshift*/\n    0,             /*nb_and*/\n    0,             /*nb_xor*/\n    0,             /*nb_or*/\n    (coercion)0,   /*nb_coerce*/\n    (unaryfunc)PySwigObject_long, /*nb_int*/\n    (unaryfunc)PySwigObject_long, /*nb_long*/\n    (unaryfunc)0,                 /*nb_float*/\n    (unaryfunc)PySwigObject_oct,  /*nb_oct*/\n    (unaryfunc)PySwigObject_hex,  /*nb_hex*/\n#if PY_VERSION_HEX >= 0x02000000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */\n#endif\n  };\n\n  static PyTypeObject PySwigObject_Type = {\n    PyObject_HEAD_INIT(&PyType_Type)\n    0,                                  /*ob_size*/\n    "PySwigObject",                     /*tp_name*/\n    sizeof(PySwigObject),               /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    /* methods */\n    (destructor)PySwigObject_dealloc,   /*tp_dealloc*/\n    (printfunc)PySwigObject_print,      /*tp_print*/\n    (getattrfunc)0,                     /*tp_getattr*/\n    (setattrfunc)0,                     /*tp_setattr*/\n    (cmpfunc)PySwigObject_compare,      /*tp_compare*/\n    (reprfunc)PySwigObject_repr,        /*tp_repr*/\n    &PySwigObject_as_number,            /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    (hashfunc)0,                        /*tp_hash*/\n    (ternaryfunc)0,                     /*tp_call*/\n    (reprfunc)PySwigObject_str,         /*tp_str*/\n    /* Space for future expansion */\n    0L,0L,0L,0L,\n    PySwigObject_Type__doc__,           /* Documentation string */\n#if PY_VERSION_HEX >= 0x02000000\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n#endif\n#if PY_VERSION_HEX >= 0x02010000\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n#endif\n#if PY_VERSION_HEX >= 0x02020000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */\n#endif\n#if PY_VERSION_HEX >= 0x02030000\n    0,                                  /* tp_del */\n#endif\n#ifdef COUNT_ALLOCS\n    0,0,0,0                             /* tp_alloc -> tp_next */\n#endif\n  };\n\n  return &PySwigObject_Type;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_FromVoidPtrAndDesc(void *ptr, const char *desc)\n{\n  PySwigObject *self = PyObject_NEW(PySwigObject, PySwigObject_GetType());\n  if (self == NULL) return NULL;\n  self->ptr = ptr;\n  self->desc = desc;\n  return (PyObject *)self;\n}\n\nSWIGRUNTIMEINLINE void *\nPySwigObject_AsVoidPtr(PyObject *self)\n{\n  return ((PySwigObject *)self)->ptr;\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigObject_GetDesc(PyObject *self)\n{\n  return ((PySwigObject *)self)->desc;\n}\n\nSWIGRUNTIMEINLINE int\nPySwigObject_Check(PyObject *op) {\n  return ((op)->ob_type == PySwigObject_GetType())\n    || (strcmp((op)->ob_type->tp_name,"PySwigObject") == 0);\n}\n\n/* -----------------------------------------------------------------------------\n * Implements a simple Swig Packed type, and use it instead of string\n * ----------------------------------------------------------------------------- */\n\ntypedef struct {\n  PyObject_HEAD\n  void *pack;\n  const char *desc;\n  size_t size;\n} PySwigPacked;\n\nSWIGRUNTIME int\nPySwigPacked_print(PySwigPacked *v, FILE *fp, int flags)\n{\n  char result[SWIG_BUFFER_SIZE];\n  fputs("<Swig Packed ", fp);\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {\n    fputs("at ", fp);\n    fputs(result, fp);\n  }\n  fputs(v->desc,fp);\n  fputs(">", fp);\n  return 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_repr(PySwigPacked *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {\n    return PyString_FromFormat("<Swig Packed at %s%s>", result, v->desc);\n  } else {\n    return PyString_FromFormat("<Swig Packed %s>", v->desc);\n  }\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_str(PySwigPacked *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){\n    return PyString_FromFormat("%s%s", result, v->desc);\n  } else {\n    return PyString_FromFormat("%s", v->desc);\n  }\n}\n\nSWIGRUNTIME int\nPySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)\n{\n  int c = strcmp(v->desc, w->desc);\n  if (c) {\n    return c;\n  } else {\n    size_t i = v->size;\n    size_t j = w->size;\n    int s = (i < j) ? -1 : (i > j) ? 1 : 0;\n    return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);\n  }\n}\n\nSWIGRUNTIME void\nPySwigPacked_dealloc(PySwigPacked *self)\n{\n  free(self->pack);\n  PyObject_DEL(self);\n}\n\nSWIGRUNTIME PyTypeObject*\nPySwigPacked_GetType() {\n  static char PySwigPacked_Type__doc__[] =\n    "Swig object carries a C/C++ instance pointer";\n\n  static PyTypeObject PySwigPacked_Type = {\n    PyObject_HEAD_INIT(&PyType_Type)\n    0,                                  /*ob_size*/\n    "PySwigPacked",                     /*tp_name*/\n    sizeof(PySwigPacked),               /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    /* methods */\n    (destructor)PySwigPacked_dealloc,   /*tp_dealloc*/\n    (printfunc)PySwigPacked_print,      /*tp_print*/\n    (getattrfunc)0,                     /*tp_getattr*/\n    (setattrfunc)0,                     /*tp_setattr*/\n    (cmpfunc)PySwigPacked_compare,      /*tp_compare*/\n    (reprfunc)PySwigPacked_repr,        /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    (hashfunc)0,                        /*tp_hash*/\n    (ternaryfunc)0,                     /*tp_call*/\n    (reprfunc)PySwigPacked_str,         /*tp_str*/\n    /* Space for future expansion */\n    0L,0L,0L,0L,\n    PySwigPacked_Type__doc__,           /* Documentation string */\n#if PY_VERSION_HEX >= 0x02000000\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n#endif\n#if PY_VERSION_HEX >= 0x02010000\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n#endif\n#if PY_VERSION_HEX >= 0x02020000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */\n#endif\n#if PY_VERSION_HEX >= 0x02030000\n    0,                                  /* tp_del */\n#endif\n#ifdef COUNT_ALLOCS\n    0,0,0,0                             /* tp_alloc -> tp_next */\n#endif\n  };\n\n  return &PySwigPacked_Type;\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_FromDataAndDesc(void *ptr, size_t size, const char *desc)\n{\n  PySwigPacked *self = PyObject_NEW(PySwigPacked, PySwigPacked_GetType());\n  if (self == NULL) {\n    return NULL;\n  } else {\n    void *pack = malloc(size);\n    memcpy(pack, ptr, size);\n    self->pack = pack;\n    self->desc = desc;\n    self->size = size;\n    return (PyObject *) self;\n  }\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)\n{\n  PySwigPacked *self = (PySwigPacked *)obj;\n  if (self->size != size) return 0;\n  memcpy(ptr, self->pack, size);\n  return self->desc;\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigPacked_GetDesc(PyObject *self)\n{\n  return ((PySwigPacked *)self)->desc;\n}\n\nSWIGRUNTIMEINLINE int\nPySwigPacked_Check(PyObject *op) {\n  return ((op)->ob_type == PySwigPacked_GetType())\n    || (strcmp((op)->ob_type->tp_name,"PySwigPacked") == 0);\n}\n\n#else\n/* -----------------------------------------------------------------------------\n * Use the old Python PyCObject instead of PySwigObject\n * ----------------------------------------------------------------------------- */\n\n#define PySwigObject_GetDesc(obj)                  PyCObject_GetDesc(obj)\n#define PySwigObject_Check(obj)            PyCObject_Check(obj)\n#define PySwigObject_AsVoidPtr(obj)        PyCObject_AsVoidPtr(obj)\n#define PySwigObject_FromVoidPtrAndDesc(p, d)  PyCObject_FromVoidPtrAndDesc(p, d, NULL)\n\n#endif\n\n#endif\n\n/* -----------------------------------------------------------------------------\n * errors manipulation\n * ----------------------------------------------------------------------------- */\n\nSWIGRUNTIME void\nSWIG_Python_TypeError(const char *type, PyObject *obj)\n{\n  if (type) {\n#if defined(SWIG_COBJECT_TYPES)\n    if (PySwigObject_Check(obj)) {\n      const char *otype = (const char *) PySwigObject_GetDesc(obj);\n      if (otype) {\n        PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'PySwigObject(%s)\' is received",\n                     type, otype);\n        return;\n      }\n    } else\n#endif\n    {\n      const char *otype = (obj ? obj->ob_type->tp_name : 0);\n      if (otype) {\n        PyObject *str = PyObject_Str(obj);\n        const char *cstr = str ? PyString_AsString(str) : 0;\n        if (cstr) {\n          PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'%s(%s)\' is received",\n                       type, otype, cstr);\n        } else {\n          PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'%s\' is received",\n                       type, otype);\n        }\n        Py_DECREF(str);\n        return;\n      }\n    }\n    PyErr_Format(PyExc_TypeError, "a \'%s\' is expected", type);\n  } else {\n    PyErr_Format(PyExc_TypeError, "unexpected type is received");\n  }\n}\n\nSWIGRUNTIMEINLINE void\nSWIG_Python_NullRef(const char *type)\n{\n  if (type) {\n    PyErr_Format(PyExc_TypeError, "null reference of type \'%s\' was received",type);\n  } else {\n    PyErr_Format(PyExc_TypeError, "null reference was received");\n  }\n}\n\nSWIGRUNTIME int\nSWIG_Python_AddErrMesg(const char* mesg, int infront)\n{\n  if (PyErr_Occurred()) {\n    PyObject *type = 0;\n    PyObject *value = 0;\n    PyObject *traceback = 0;\n    PyErr_Fetch(&type, &value, &traceback);\n    if (value) {\n      PyObject *old_str = PyObject_Str(value);\n      Py_XINCREF(type);\n      PyErr_Clear();\n      if (infront) {\n        PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));\n      } else {\n        PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);\n      }\n      Py_DECREF(old_str);\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nSWIGRUNTIME int\nSWIG_Python_ArgFail(int argnum)\n{\n  if (PyErr_Occurred()) {\n    /* add information about failing argument */\n    char mesg[256];\n    sprintf(mesg, "argument number %d:", argnum);\n    return SWIG_Python_AddErrMesg(mesg, 1);\n  } else {\n    return 0;\n  }\n}\n\n\n/* -----------------------------------------------------------------------------\n * pointers/data manipulation\n * ----------------------------------------------------------------------------- */\n\n/* Convert a pointer value */\nSWIGRUNTIME int\nSWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {\n  swig_type_info *tc;\n  const char *c = 0;\n  static PyObject *SWIG_this = 0;\n  int    newref = 0;\n  PyObject  *pyobj = 0;\n  void *vptr;\n\n  if (!obj) return 0;\n  if (obj == Py_None) {\n    *ptr = 0;\n    return 0;\n  }\n\n#ifdef SWIG_COBJECT_TYPES\n  if (!(PySwigObject_Check(obj))) {\n    if (!SWIG_this)\n      SWIG_this = PyString_FromString("this");\n    pyobj = obj;\n    obj = PyObject_GetAttr(obj,SWIG_this);\n    newref = 1;\n    if (!obj) goto type_error;\n    if (!PySwigObject_Check(obj)) {\n      Py_DECREF(obj);\n      goto type_error;\n    }\n  }\n  vptr = PySwigObject_AsVoidPtr(obj);\n  c = (const char *) PySwigObject_GetDesc(obj);\n  if (newref) { Py_DECREF(obj); }\n  goto type_check;\n#else\n  if (!(PyString_Check(obj))) {\n    if (!SWIG_this)\n      SWIG_this = PyString_FromString("this");\n    pyobj = obj;\n    obj = PyObject_GetAttr(obj,SWIG_this);\n    newref = 1;\n    if (!obj) goto type_error;\n    if (!PyString_Check(obj)) {\n      Py_DECREF(obj);\n      goto type_error;\n    }\n  }\n  c = PyString_AS_STRING(obj);\n  /* Pointer values must start with leading underscore */\n  c = SWIG_UnpackVoidPtr(c, &vptr, ty->name);\n  if (newref) { Py_DECREF(obj); }\n  if (!c) goto type_error;\n#endif\n\ntype_check:\n\n  if (ty) {\n    tc = SWIG_TypeCheck(c,ty);\n    if (!tc) goto type_error;\n    *ptr = SWIG_TypeCast(tc,vptr);\n  }\n\n  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {\n    PyObject_SetAttrString(pyobj,(char*)"thisown",Py_False);\n  }\n  return 0;\n\ntype_error:\n  PyErr_Clear();\n  if (pyobj && !obj) {\n    obj = pyobj;\n    if (PyCFunction_Check(obj)) {\n      /* here we get the method pointer for callbacks */\n      char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);\n      c = doc ? strstr(doc, "swig_ptr: ") : 0;\n      if (c) {\n        c = SWIG_UnpackVoidPtr(c + 10, &vptr, ty->name);\n        if (!c) goto type_error;\n        goto type_check;\n      }\n    }\n  }\n  if (flags & SWIG_POINTER_EXCEPTION) {\n    if (ty) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n    } else {\n      SWIG_Python_TypeError("C/C++ pointer", obj);\n    }\n  }\n  return -1;\n}\n\n/* Convert a pointer value, signal an exception on a type mismatch */\nSWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n    if (flags & SWIG_POINTER_EXCEPTION) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n  }\n  return result;\n}\n\n/* Convert a packed value value */\nSWIGRUNTIME int\nSWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {\n  swig_type_info *tc;\n  const char *c = 0;\n\n#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)\n  c = PySwigPacked_UnpackData(obj, ptr, sz);\n#else\n  if ((!obj) || (!PyString_Check(obj))) goto type_error;\n  c = PyString_AS_STRING(obj);\n  /* Pointer values must start with leading underscore */\n  c = SWIG_UnpackDataName(c, ptr, sz, ty->name);\n#endif\n  if (!c) goto type_error;\n  if (ty) {\n    tc = SWIG_TypeCheck(c,ty);\n    if (!tc) goto type_error;\n  }\n  return 0;\n\ntype_error:\n  PyErr_Clear();\n  if (flags & SWIG_POINTER_EXCEPTION) {\n    if (ty) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n    } else {\n      SWIG_Python_TypeError("C/C++ packed data", obj);\n    }\n  }\n  return -1;\n}\n\n/* Create a new array object */\nSWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {\n  PyObject *robj = 0;\n  if (!ptr) {\n    Py_INCREF(Py_None);\n    return Py_None;\n  }\n#ifdef SWIG_COBJECT_TYPES\n  robj = PySwigObject_FromVoidPtrAndDesc((void *) ptr, (char *)type->name);\n#else\n  {\n    char result[SWIG_BUFFER_SIZE];\n    robj = SWIG_PackVoidPtr(result, ptr, type->name, sizeof(result)) ?\n      PyString_FromString(result) : 0;\n  }\n#endif\n  if (!robj || (robj == Py_None)) return robj;\n  if (type->clientdata) {\n    PyObject *inst;\n    PyObject *args = Py_BuildValue((char*)"(O)", robj);\n    Py_DECREF(robj);\n    inst = PyObject_CallObject((PyObject *) type->clientdata, args);\n    Py_DECREF(args);\n    if (inst) {\n      if (own) {\n        PyObject_SetAttrString(inst,(char*)"thisown",Py_True);\n      }\n      robj = inst;\n    }\n  }\n  return robj;\n}\n\nSWIGRUNTIME PyObject *\nSWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {\n  PyObject *robj = 0;\n  if (!ptr) {\n    Py_INCREF(Py_None);\n    return Py_None;\n  }\n#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)\n  robj = PySwigPacked_FromDataAndDesc((void *) ptr, sz, (char *)type->name);\n#else\n  {\n    char result[SWIG_BUFFER_SIZE];\n    robj = SWIG_PackDataName(result, ptr, sz, type->name, sizeof(result)) ?\n      PyString_FromString(result) : 0;\n  }\n#endif\n  return robj;\n}\n\n/* -----------------------------------------------------------------------------*\n *  Get type list\n * -----------------------------------------------------------------------------*/\n\n#ifdef SWIG_LINK_RUNTIME\nvoid *SWIG_ReturnGlobalTypeList(void *);\n#endif\n\nSWIGRUNTIME swig_type_info **\nSWIG_Python_GetTypeListHandle() {\n  static void *type_pointer = (void *)0;\n  /* first check if module already created */\n  if (!type_pointer) {\n#ifdef SWIG_LINK_RUNTIME\n    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);\n#else\n    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,\n                                    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);\n    if (PyErr_Occurred()) {\n      PyErr_Clear();\n      type_pointer = (void *)0;\n    }\n  }\n#endif\n  return (swig_type_info **) type_pointer;\n}\n\n/*\n  Search for a swig_type_info structure\n */\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_Python_GetTypeList() {\n  swig_type_info **tlh = SWIG_Python_GetTypeListHandle();\n  return tlh ? *tlh : (swig_type_info*)0;\n}\n\n#define SWIG_Runtime_GetTypeList SWIG_Python_GetTypeList\n\n#ifdef __cplusplus\n}\n#endif\n\n/* -----------------------------------------------------------------------------*\n   Standard SWIG API for use inside user code.\n\n   You need to include in your code as follow:\n\n#include <Python.h>            // or using your favorite language\n#include <swigrun.swg>\n#include <python/pyrun.swg>    // or using your favorite language\n#include <runtime.swg>\n\n * -----------------------------------------------------------------------------*/\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_Runtime_TypeQuery(const char *name) {\n  swig_type_info *tl = SWIG_Runtime_GetTypeList();\n  return SWIG_TypeQueryTL(tl, name);\n}\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_Runtime_TypeRegister(swig_type_info *ti) {\n  swig_type_info *tl = SWIG_Runtime_GetTypeList();\n  return SWIG_TypeRegisterTL(&tl, ti);\n}\n\nSWIGRUNTIMEINLINE void\nSWIG_Runtime_TypeClientData(swig_type_info *ti, void *clientdata) {\n  swig_type_info *tl = SWIG_Runtime_GetTypeList();\n  SWIG_TypeClientDataTL(tl, ti, clientdata);\n}\n\nSWIGRUNTIMEINLINE void\nSWIG_Runtime_PropagateClientData(swig_type_info *type) {\n  swig_type_info *tl = SWIG_Runtime_GetTypeList();\n  SWIG_PropagateClientDataTL(tl, type);\n}\n\n#define SWIG_GetTypeList()            SWIG_Runtime_GetTypeList()\n#define SWIG_TypeQuery(name)          SWIG_Runtime_TypeQuery(name)\n#define SWIG_TypeRegister(ti)         SWIG_Runtime_TypeRegister(ti)\n#define SWIG_TypeClientData(ti, cd)   SWIG_Runtime_TypeClientData(ti, cd)\n#define SWIG_PropagateClientData(ti)  SWIG_Runtime_PropagateClientData(ti)\n\n'
swigptr2_code_v2 = '\n/* ----------------------------------------------------------------------------\n * This file was automatically generated by SWIG (http://www.swig.org).\n * Version 1.3.25\n *\n * This file is not intended to be easily readable and contains a number of\n * coding conventions designed to improve portability and efficiency. Do not make\n * changes to this file unless you know what you are doing--modify the SWIG\n * interface file instead.\n * ----------------------------------------------------------------------------- */\n\n/***********************************************************************\n *\n *  This section contains generic SWIG labels for method/variable\n *  declarations/attributes, and other compiler dependent labels.\n *\n ************************************************************************/\n\n/*\n   SWIGTEMPLATEDISAMBIGUATOR is needed when wrapping template calls\n   (cwrap.c:Swig_cfunction_call/Swig_cmethod_call), as in\n\n     result = nspace::template function<int >(arg1);\n     result = arg1->template method<int >(arg2);\n\n    SWIGTEMPLATEDISAMBIGUATOR is compiler dependent (common.swg),\n      - SUN Studio requires \'template\',\n      - gcc-3.4 forbids the use of \'template\'.\n      - gcc-3.2.3 produces internal errors if you use \'template\'\n*/\n#ifndef SWIGTEMPLATEDISAMBIGUATOR\n#  if defined(__SUNPRO_CC)\n#    define SWIGTEMPLATEDISAMBIGUATOR template\n#  else\n#    define SWIGTEMPLATEDISAMBIGUATOR\n#  endif\n#endif\n\n/* inline attribute */\n#ifndef SWIGINLINE\n# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))\n#   define SWIGINLINE inline\n# else\n#   define SWIGINLINE\n# endif\n#endif\n\n/* attritbute passed for some compilers to avoid \'unused\' warnings */\n#ifndef SWIGUNUSED\n# if defined(__GNUC__) || defined(__ICC)\n#   define SWIGUNUSED __attribute__ ((unused))\n# else\n#   define SWIGUNUSED\n# endif\n#endif\n\n/* internal SWIG method */\n#ifndef SWIGINTERN\n# define SWIGINTERN static SWIGUNUSED\n#endif\n\n/* internal inline SWIG method */\n#ifndef SWIGINTERNINLINE\n# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE\n#endif\n\n/* how we export a method such that it can go in to a shared or dll library */\n#ifndef SWIGEXPORT\n# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n#   if defined(_MSC_VER) || defined(__GNUC__)\n#     if defined(STATIC_LINKED)\n#       define SWIGEXPORT(a) a\n#     else\n#       define SWIGEXPORT(a) __declspec(dllexport) a\n#     endif\n#   else\n#     if defined(__BORLANDC__)\n#       define SWIGEXPORT(a) a _export\n#     else\n#       define SWIGEXPORT(a) a\n#     endif\n#   endif\n# else\n#   define SWIGEXPORT(a) a\n# endif\n#endif\n\n/***********************************************************************\n * swigrun.swg\n *\n *     This file contains generic CAPI SWIG runtime support for pointer\n *     type checking.\n *\n ************************************************************************/\n\n/* This should only be incremented when either the layout of swig_type_info changes,\n   or for whatever reason, the runtime changes incompatibly */\n#define SWIG_RUNTIME_VERSION "2"\n\n/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */\n#ifdef SWIG_TYPE_TABLE\n# define SWIG_QUOTE_STRING(x) #x\n# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)\n# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)\n#else\n# define SWIG_TYPE_TABLE_NAME\n#endif\n\n/*\n  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for\n  creating a static or dynamic library from the swig runtime code.\n  In 99.9% of the cases, swig just needs to declare them as \'static\'.\n\n  But only do this if is strictly necessary, ie, if you have problems\n  with your compiler or so.\n*/\n\n#ifndef SWIGRUNTIME\n# define SWIGRUNTIME SWIGINTERN\n#endif\n\n#ifndef SWIGRUNTIMEINLINE\n# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE\n#endif\n\n#include <string.h>\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\ntypedef void *(*swig_converter_func)(void *);\ntypedef struct swig_type_info *(*swig_dycast_func)(void **);\n\n/* Structure to store inforomation on one type */\ntypedef struct swig_type_info {\n  const char             *name;                 /* mangled name of this type */\n  const char             *str;                  /* human readable name of this type */\n  swig_dycast_func        dcast;                /* dynamic cast function down a hierarchy */\n  struct swig_cast_info  *cast;                 /* linked list of types that can cast into this type */\n  void                   *clientdata;           /* language specific type data */\n} swig_type_info;\n\n/* Structure to store a type and conversion function used for casting */\ntypedef struct swig_cast_info {\n  swig_type_info         *type;                 /* pointer to type that is equivalent to this type */\n  swig_converter_func     converter;            /* function to cast the void pointers */\n  struct swig_cast_info  *next;                 /* pointer to next cast in linked list */\n  struct swig_cast_info  *prev;                 /* pointer to the previous cast */\n} swig_cast_info;\n\n/* Structure used to store module information\n * Each module generates one structure like this, and the runtime collects\n * all of these structures and stores them in a circularly linked list.*/\ntypedef struct swig_module_info {\n  swig_type_info         **types;               /* Array of pointers to swig_type_info structures that are in this module */\n  size_t                 size;                  /* Number of types in this module */\n  struct swig_module_info *next;                /* Pointer to next element in circularly linked list */\n  swig_type_info         **type_initial;        /* Array of initially generated type structures */\n  swig_cast_info         **cast_initial;        /* Array of initially generated casting structures */\n  void                    *clientdata;          /* Language specific module data */\n} swig_module_info;\n\n\n/*\n  Compare two type names skipping the space characters, therefore\n  "char*" == "char *" and "Class<int>" == "Class<int >", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping \' \'.\n*/\nSWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n                  const char *f2, const char *l2) {\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == \' \') && (f1 != l1)) ++f1;\n    while ((*f2 == \' \') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (int)(*f1 - *f2);\n  }\n  return (l1 - f1) - (l2 - f2);\n}\n\n/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if not equal, 1 if equal\n*/\nSWIGRUNTIME int\nSWIG_TypeEquiv(const char *nb, const char *tb) {\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == \'|\') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}\n\n/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\nSWIGRUNTIME int\nSWIG_TypeCompare(const char *nb, const char *tb) {\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == \'|\') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}\n\n\n/* think of this as a c++ template<> or a scheme macro */\n#define SWIG_TypeCheck_Template(comparison, ty)           if (ty) {                                                 swig_cast_info *iter = ty->cast;                        while (iter) {                                            if (comparison) {                                         if (iter == ty->cast) return iter;                      /* Move iter to the top of the linked list */           iter->prev->next = iter->next;                          if (iter->next)                                           iter->next->prev = iter->prev;                        iter->next = ty->cast;                                  iter->prev = 0;                                         if (ty->cast) ty->cast->prev = iter;                    ty->cast = iter;                                        return iter;                                          }                                                       iter = iter->next;                                    }                                                     }                                                       return 0\n\n/*\n  Check the typename\n*/\nSWIGRUNTIME swig_cast_info *\nSWIG_TypeCheck(const char *c, swig_type_info *ty) {\n  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);\n}\n\n/* Same as previous function, except strcmp is replaced with a pointer comparison */\nSWIGRUNTIME swig_cast_info *\nSWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {\n  SWIG_TypeCheck_Template(iter->type == from, into);\n}\n\n/*\n  Cast a pointer up an inheritance hierarchy\n*/\nSWIGRUNTIMEINLINE void *\nSWIG_TypeCast(swig_cast_info *ty, void *ptr) {\n  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);\n}\n\n/*\n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}\n\n/*\n  Return the name associated with this type\n*/\nSWIGRUNTIMEINLINE const char *\nSWIG_TypeName(const swig_type_info *ty) {\n  return ty->name;\n}\n\n/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\nSWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type) {\n  /* The "str" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == \'|\') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}\n\n/*\n   Set the clientdata field for a type\n*/\nSWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata) {\n  if (!ti->clientdata) {\n    swig_cast_info *cast = ti->cast;\n    /* if (ti->clientdata == clientdata) return; */\n    ti->clientdata = clientdata;\n\n    while (cast) {\n      if (!cast->converter)\n        SWIG_TypeClientData(cast->type, clientdata);\n      cast = cast->next;\n    }\n  }\n}\n\n/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start,\n                            swig_module_info *end,\n                            const char *name) {\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n        /* since l+r >= 0, we can (>> 1) instead (/ 2) */\n        register size_t i = (l + r) >> 1;\n        const char *iname = iter->types[i]->name;\n        if (iname) {\n          register int compare = strcmp(name, iname);\n          if (compare == 0) {\n            return iter->types[i];\n          } else if (compare < 0) {\n            if (i) {\n              r = i - 1;\n            } else {\n              break;\n            }\n          } else if (compare > 0) {\n            l = i + 1;\n          }\n        } else {\n          break; /* should never happen */\n        }\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}\n\n/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start,\n                     swig_module_info *end,\n                     const char *name) {\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn\'t been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n        if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n          return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n\n  /* neither found a match */\n  return 0;\n}\n\n\n/*\n   Pack binary data into a string\n*/\nSWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz) {\n  static const char hex[17] = "0123456789abcdef";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}\n\n/*\n   Unpack binary data from a string\n*/\nSWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz) {\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu = 0;\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu = ((d - \'0\') << 4);\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu = ((d - (\'a\'-10)) << 4);\n    else\n      return (char *) 0;\n    d = *(c++);\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu |= (d - \'0\');\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu |= (d - (\'a\'-10));\n    else\n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}\n\n/*\n   Pack \'void *\' into a string buffer.\n*/\nSWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = \'_\';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}\n\nSWIGRUNTIME const char *\nSWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {\n  if (*c != \'_\') {\n    if (strcmp(c,"NULL") == 0) {\n      *ptr = (void *) 0;\n      return name;\n    } else {\n      return 0;\n    }\n  }\n  return SWIG_UnpackData(++c,ptr,sizeof(void *));\n}\n\nSWIGRUNTIME char *\nSWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {\n  char *r = buff;\n  size_t lname = (name ? strlen(name) : 0);\n  if ((2*sz + 2 + lname) > bsz) return 0;\n  *(r++) = \'_\';\n  r = SWIG_PackData(r,ptr,sz);\n  if (lname) {\n    strncpy(r,name,lname+1);\n  } else {\n    *r = 0;\n  }\n  return buff;\n}\n\nSWIGRUNTIME const char *\nSWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {\n  if (*c != \'_\') {\n    if (strcmp(c,"NULL") == 0) {\n      memset(ptr,0,sz);\n      return name;\n    } else {\n      return 0;\n    }\n  }\n  return SWIG_UnpackData(++c,ptr,sz);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/***********************************************************************\n * pyrun.swg\n *\n *     This file contains the runtime support for Python modules\n *     and includes code for managing global variables and pointer\n *     type checking.\n *\n * Author : David Beazley (beazley@cs.uchicago.edu)\n ************************************************************************/\n\n/* Common SWIG API */\n#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)\n#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)\n#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)\n\n\n/* Python-specific SWIG API */\n#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)\n#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)\n\n/* Runtime API */\n#define SWIG_GetModule(clientdata) SWIG_Python_GetModule()\n#define SWIG_SetModule(clientdata, pointer) SWIG_Python_SetModule(pointer)\n\n/* -----------------------------------------------------------------------------\n * Pointer declarations\n * ----------------------------------------------------------------------------- */\n/*\n  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent\n  C/C++ pointers in the python side. Very useful for debugging, but\n  not always safe.\n*/\n#if !defined(SWIG_NO_COBJECT_TYPES) && !defined(SWIG_COBJECT_TYPES)\n#  define SWIG_COBJECT_TYPES\n#endif\n\n/* Flags for pointer conversion */\n#define SWIG_POINTER_EXCEPTION     0x1\n#define SWIG_POINTER_DISOWN        0x2\n\n\n/* Add PyOS_snprintf for old Pythons */\n#if PY_VERSION_HEX < 0x02020000\n#define PyOS_snprintf snprintf\n#endif\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n/* -----------------------------------------------------------------------------\n * Create a new pointer string\n * ----------------------------------------------------------------------------- */\n#ifndef SWIG_BUFFER_SIZE\n#define SWIG_BUFFER_SIZE 1024\n#endif\n\n#if defined(SWIG_COBJECT_TYPES)\n#if !defined(SWIG_COBJECT_PYTHON)\n/* -----------------------------------------------------------------------------\n * Implements a simple Swig Object type, and use it instead of PyCObject\n * ----------------------------------------------------------------------------- */\n\ntypedef struct {\n  PyObject_HEAD\n  void *ptr;\n  const char *desc;\n} PySwigObject;\n\n/* Declarations for objects of type PySwigObject */\n\nSWIGRUNTIME int\nPySwigObject_print(PySwigObject *v, FILE *fp, int flags)\n{\n  char result[SWIG_BUFFER_SIZE];\n  flags = flags;\n  if (SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result))) {\n    fputs("<Swig Object at ", fp); fputs(result, fp); fputs(">", fp);\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_repr(PySwigObject *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?\n    PyString_FromFormat("<Swig Object at %s>", result) : 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_str(PySwigObject *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  return SWIG_PackVoidPtr(result, v->ptr, v->desc, sizeof(result)) ?\n    PyString_FromString(result) : 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_long(PySwigObject *v)\n{\n  return PyLong_FromVoidPtr(v->ptr);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_format(const char* fmt, PySwigObject *v)\n{\n  PyObject *res = NULL;\n  PyObject *args = PyTuple_New(1);\n  if (args && (PyTuple_SetItem(args, 0, PySwigObject_long(v)) == 0)) {\n    PyObject *ofmt = PyString_FromString(fmt);\n    if (ofmt) {\n      res = PyString_Format(ofmt,args);\n      Py_DECREF(ofmt);\n    }\n    Py_DECREF(args);\n  }\n  return res;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_oct(PySwigObject *v)\n{\n  return PySwigObject_format("%o",v);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_hex(PySwigObject *v)\n{\n  return PySwigObject_format("%x",v);\n}\n\nSWIGRUNTIME int\nPySwigObject_compare(PySwigObject *v, PySwigObject *w)\n{\n  int c = strcmp(v->desc, w->desc);\n  if (c) {\n    return (c > 0) ? 1 : -1;\n  } else {\n    void *i = v->ptr;\n    void *j = w->ptr;\n    return (i < j) ? -1 : ((i > j) ? 1 : 0);\n  }\n}\n\nSWIGRUNTIME void\nPySwigObject_dealloc(PySwigObject *self)\n{\n  PyObject_DEL(self);\n}\n\nSWIGRUNTIME PyTypeObject*\nPySwigObject_type(void) {\n  static char pyswigobject_type__doc__[] =\n    "Swig object carries a C/C++ instance pointer";\n\n  static PyNumberMethods PySwigObject_as_number = {\n    (binaryfunc)0, /*nb_add*/\n    (binaryfunc)0, /*nb_subtract*/\n    (binaryfunc)0, /*nb_multiply*/\n    (binaryfunc)0, /*nb_divide*/\n    (binaryfunc)0, /*nb_remainder*/\n    (binaryfunc)0, /*nb_divmod*/\n    (ternaryfunc)0,/*nb_power*/\n    (unaryfunc)0,  /*nb_negative*/\n    (unaryfunc)0,  /*nb_positive*/\n    (unaryfunc)0,  /*nb_absolute*/\n    (inquiry)0,    /*nb_nonzero*/\n    0,             /*nb_invert*/\n    0,             /*nb_lshift*/\n    0,             /*nb_rshift*/\n    0,             /*nb_and*/\n    0,             /*nb_xor*/\n    0,             /*nb_or*/\n    (coercion)0,   /*nb_coerce*/\n    (unaryfunc)PySwigObject_long, /*nb_int*/\n    (unaryfunc)PySwigObject_long, /*nb_long*/\n    (unaryfunc)0,                 /*nb_float*/\n    (unaryfunc)PySwigObject_oct,  /*nb_oct*/\n    (unaryfunc)PySwigObject_hex,  /*nb_hex*/\n#if PY_VERSION_HEX >= 0x02000000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */\n#endif\n  };\n\n  static PyTypeObject pyswigobject_type\n#if !defined(__cplusplus)\n  ;\n  static int type_init = 0;\n  if (!type_init) {\n    PyTypeObject tmp\n#endif\n    = {\n    PyObject_HEAD_INIT(&PyType_Type)\n    0,                                  /*ob_size*/\n    "PySwigObject",                     /*tp_name*/\n    sizeof(PySwigObject),               /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    /* methods */\n    (destructor)PySwigObject_dealloc,   /*tp_dealloc*/\n    (printfunc)PySwigObject_print,      /*tp_print*/\n    (getattrfunc)0,                     /*tp_getattr*/\n    (setattrfunc)0,                     /*tp_setattr*/\n    (cmpfunc)PySwigObject_compare,      /*tp_compare*/\n    (reprfunc)PySwigObject_repr,        /*tp_repr*/\n    &PySwigObject_as_number,            /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    (hashfunc)0,                        /*tp_hash*/\n    (ternaryfunc)0,                     /*tp_call*/\n    (reprfunc)PySwigObject_str,         /*tp_str*/\n    /* Space for future expansion */\n    0,0,0,0,\n    pyswigobject_type__doc__,           /* Documentation string */\n#if PY_VERSION_HEX >= 0x02000000\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n#endif\n#if PY_VERSION_HEX >= 0x02010000\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n#endif\n#if PY_VERSION_HEX >= 0x02020000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */\n#endif\n#if PY_VERSION_HEX >= 0x02030000\n    0,                                  /* tp_del */\n#endif\n#ifdef COUNT_ALLOCS\n    0,0,0,0                             /* tp_alloc -> tp_next */\n#endif\n    };\n#if !defined(__cplusplus)\n    pyswigobject_type = tmp;\n    type_init = 1;\n  }\n#endif\n  return &pyswigobject_type;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_FromVoidPtrAndDesc(void *ptr, const char *desc)\n{\n  PySwigObject *self = PyObject_NEW(PySwigObject, PySwigObject_type());\n  if (self) {\n    self->ptr = ptr;\n    self->desc = desc;\n  }\n  return (PyObject *)self;\n}\n\nSWIGRUNTIMEINLINE void *\nPySwigObject_AsVoidPtr(PyObject *self)\n{\n  return ((PySwigObject *)self)->ptr;\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigObject_GetDesc(PyObject *self)\n{\n  return ((PySwigObject *)self)->desc;\n}\n\nSWIGRUNTIMEINLINE int\nPySwigObject_Check(PyObject *op) {\n  return ((op)->ob_type == PySwigObject_type())\n    || (strcmp((op)->ob_type->tp_name,"PySwigObject") == 0);\n}\n\n/* -----------------------------------------------------------------------------\n * Implements a simple Swig Packed type, and use it instead of string\n * ----------------------------------------------------------------------------- */\n\ntypedef struct {\n  PyObject_HEAD\n  void *pack;\n  const char *desc;\n  size_t size;\n} PySwigPacked;\n\nSWIGRUNTIME int\nPySwigPacked_print(PySwigPacked *v, FILE *fp, int flags)\n{\n  char result[SWIG_BUFFER_SIZE];\n  flags = flags;\n  fputs("<Swig Packed ", fp);\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {\n    fputs("at ", fp);\n    fputs(result, fp);\n  }\n  fputs(v->desc,fp);\n  fputs(">", fp);\n  return 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_repr(PySwigPacked *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {\n    return PyString_FromFormat("<Swig Packed at %s%s>", result, v->desc);\n  } else {\n    return PyString_FromFormat("<Swig Packed %s>", v->desc);\n  }\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_str(PySwigPacked *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){\n    return PyString_FromFormat("%s%s", result, v->desc);\n  } else {\n    return PyString_FromFormat("%s", v->desc);\n  }\n}\n\nSWIGRUNTIME int\nPySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)\n{\n  int c = strcmp(v->desc, w->desc);\n  if (c) {\n    return (c > 0) ? 1 : -1;\n  } else {\n    size_t i = v->size;\n    size_t j = w->size;\n    int s = (i < j) ? -1 : ((i > j) ? 1 : 0);\n    return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);\n  }\n}\n\nSWIGRUNTIME void\nPySwigPacked_dealloc(PySwigPacked *self)\n{\n  free(self->pack);\n  PyObject_DEL(self);\n}\n\nSWIGRUNTIME PyTypeObject*\nPySwigPacked_type(void) {\n  static char pyswigpacked_type__doc__[] =\n    "Swig object carries a C/C++ instance pointer";\n  static PyTypeObject pyswigpacked_type\n#if !defined(__cplusplus)\n  ;\n  static int type_init = 0;\n  if (!type_init) {\n    PyTypeObject tmp\n#endif\n    = {\n    PyObject_HEAD_INIT(&PyType_Type)\n    0,                                  /*ob_size*/\n    "PySwigPacked",                     /*tp_name*/\n    sizeof(PySwigPacked),               /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    /* methods */\n    (destructor)PySwigPacked_dealloc,   /*tp_dealloc*/\n    (printfunc)PySwigPacked_print,      /*tp_print*/\n    (getattrfunc)0,                     /*tp_getattr*/\n    (setattrfunc)0,                     /*tp_setattr*/\n    (cmpfunc)PySwigPacked_compare,      /*tp_compare*/\n    (reprfunc)PySwigPacked_repr,        /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    (hashfunc)0,                        /*tp_hash*/\n    (ternaryfunc)0,                     /*tp_call*/\n    (reprfunc)PySwigPacked_str,         /*tp_str*/\n    /* Space for future expansion */\n    0,0,0,0,\n    pyswigpacked_type__doc__,           /* Documentation string */\n#if PY_VERSION_HEX >= 0x02000000\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n#endif\n#if PY_VERSION_HEX >= 0x02010000\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n#endif\n#if PY_VERSION_HEX >= 0x02020000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */\n#endif\n#if PY_VERSION_HEX >= 0x02030000\n    0,                                  /* tp_del */\n#endif\n#ifdef COUNT_ALLOCS\n    0,0,0,0                             /* tp_alloc -> tp_next */\n#endif\n    };\n#if !defined(__cplusplus)\n    pyswigpacked_type = tmp;\n    type_init = 1;\n  }\n#endif\n  return &pyswigpacked_type;\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_FromDataAndDesc(void *ptr, size_t size, const char *desc)\n{\n  PySwigPacked *self = PyObject_NEW(PySwigPacked, PySwigPacked_type());\n  if (self == NULL) {\n    return NULL;\n  } else {\n    void *pack = malloc(size);\n    if (pack) {\n      memcpy(pack, ptr, size);\n      self->pack = pack;\n      self->desc = desc;\n      self->size = size;\n      return (PyObject *) self;\n    }\n    return NULL;\n  }\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)\n{\n  PySwigPacked *self = (PySwigPacked *)obj;\n  if (self->size != size) return 0;\n  memcpy(ptr, self->pack, size);\n  return self->desc;\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigPacked_GetDesc(PyObject *self)\n{\n  return ((PySwigPacked *)self)->desc;\n}\n\nSWIGRUNTIMEINLINE int\nPySwigPacked_Check(PyObject *op) {\n  return ((op)->ob_type == PySwigPacked_type())\n    || (strcmp((op)->ob_type->tp_name,"PySwigPacked") == 0);\n}\n\n#else\n/* -----------------------------------------------------------------------------\n * Use the old Python PyCObject instead of PySwigObject\n * ----------------------------------------------------------------------------- */\n\n#define PySwigObject_GetDesc(obj)                  PyCObject_GetDesc(obj)\n#define PySwigObject_Check(obj)            PyCObject_Check(obj)\n#define PySwigObject_AsVoidPtr(obj)        PyCObject_AsVoidPtr(obj)\n#define PySwigObject_FromVoidPtrAndDesc(p, d)  PyCObject_FromVoidPtrAndDesc(p, d, NULL)\n\n#endif\n\n#endif\n\n/* -----------------------------------------------------------------------------\n * errors manipulation\n * ----------------------------------------------------------------------------- */\n\nSWIGRUNTIME void\nSWIG_Python_TypeError(const char *type, PyObject *obj)\n{\n  if (type) {\n#if defined(SWIG_COBJECT_TYPES)\n    if (obj && PySwigObject_Check(obj)) {\n      const char *otype = (const char *) PySwigObject_GetDesc(obj);\n      if (otype) {\n        PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'PySwigObject(%s)\' is received",\n                     type, otype);\n        return;\n      }\n    } else\n#endif\n    {\n      const char *otype = (obj ? obj->ob_type->tp_name : 0);\n      if (otype) {\n        PyObject *str = PyObject_Str(obj);\n        const char *cstr = str ? PyString_AsString(str) : 0;\n        if (cstr) {\n          PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'%s(%s)\' is received",\n                       type, otype, cstr);\n        } else {\n          PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'%s\' is received",\n                       type, otype);\n        }\n        Py_XDECREF(str);\n        return;\n      }\n    }\n    PyErr_Format(PyExc_TypeError, "a \'%s\' is expected", type);\n  } else {\n    PyErr_Format(PyExc_TypeError, "unexpected type is received");\n  }\n}\n\nSWIGRUNTIMEINLINE void\nSWIG_Python_NullRef(const char *type)\n{\n  if (type) {\n    PyErr_Format(PyExc_TypeError, "null reference of type \'%s\' was received",type);\n  } else {\n    PyErr_Format(PyExc_TypeError, "null reference was received");\n  }\n}\n\nSWIGRUNTIME int\nSWIG_Python_AddErrMesg(const char* mesg, int infront)\n{\n  if (PyErr_Occurred()) {\n    PyObject *type = 0;\n    PyObject *value = 0;\n    PyObject *traceback = 0;\n    PyErr_Fetch(&type, &value, &traceback);\n    if (value) {\n      PyObject *old_str = PyObject_Str(value);\n      Py_XINCREF(type);\n      PyErr_Clear();\n      if (infront) {\n        PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));\n      } else {\n        PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);\n      }\n      Py_DECREF(old_str);\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nSWIGRUNTIME int\nSWIG_Python_ArgFail(int argnum)\n{\n  if (PyErr_Occurred()) {\n    /* add information about failing argument */\n    char mesg[256];\n    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);\n    return SWIG_Python_AddErrMesg(mesg, 1);\n  } else {\n    return 0;\n  }\n}\n\n\n/* -----------------------------------------------------------------------------\n * pointers/data manipulation\n * ----------------------------------------------------------------------------- */\n\n/* Convert a pointer value */\nSWIGRUNTIME int\nSWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {\n  swig_cast_info *tc;\n  const char *c = 0;\n  static PyObject *SWIG_this = 0;\n  int    newref = 0;\n  PyObject  *pyobj = 0;\n  void *vptr;\n\n  if (!obj) return 0;\n  if (obj == Py_None) {\n    *ptr = 0;\n    return 0;\n  }\n\n#ifdef SWIG_COBJECT_TYPES\n  if (!(PySwigObject_Check(obj))) {\n    if (!SWIG_this)\n      SWIG_this = PyString_FromString("this");\n    pyobj = obj;\n    obj = PyObject_GetAttr(obj,SWIG_this);\n    newref = 1;\n    if (!obj) goto type_error;\n    if (!PySwigObject_Check(obj)) {\n      Py_DECREF(obj);\n      goto type_error;\n    }\n  }\n  vptr = PySwigObject_AsVoidPtr(obj);\n  c = (const char *) PySwigObject_GetDesc(obj);\n  if (newref) { Py_DECREF(obj); }\n  goto type_check;\n#else\n  if (!(PyString_Check(obj))) {\n    if (!SWIG_this)\n      SWIG_this = PyString_FromString("this");\n    pyobj = obj;\n    obj = PyObject_GetAttr(obj,SWIG_this);\n    newref = 1;\n    if (!obj) goto type_error;\n    if (!PyString_Check(obj)) {\n      Py_DECREF(obj);\n      goto type_error;\n    }\n  }\n  c = PyString_AS_STRING(obj);\n  /* Pointer values must start with leading underscore */\n  c = SWIG_UnpackVoidPtr(c, &vptr, ty->name);\n  if (newref) { Py_DECREF(obj); }\n  if (!c) goto type_error;\n#endif\n\ntype_check:\n  if (ty) {\n    tc = SWIG_TypeCheck(c,ty);\n    if (!tc) goto type_error;\n    *ptr = SWIG_TypeCast(tc,vptr);\n  } else {\n    *ptr = vptr;\n  }\n  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {\n    PyObject_SetAttrString(pyobj,(char*)"thisown",Py_False);\n  }\n  return 0;\n\ntype_error:\n  PyErr_Clear();\n  if (pyobj && !obj) {\n    obj = pyobj;\n    if (PyCFunction_Check(obj)) {\n      /* here we get the method pointer for callbacks */\n      char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);\n      c = doc ? strstr(doc, "swig_ptr: ") : 0;\n      if (c) {\n        c = ty ? SWIG_UnpackVoidPtr(c + 10, &vptr, ty->name) : 0;\n        if (!c) goto type_error;\n        goto type_check;\n      }\n    }\n  }\n  if (flags & SWIG_POINTER_EXCEPTION) {\n    if (ty) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n    } else {\n      SWIG_Python_TypeError("C/C++ pointer", obj);\n    }\n  }\n  return -1;\n}\n\n/* Convert a pointer value, signal an exception on a type mismatch */\nSWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n    if (flags & SWIG_POINTER_EXCEPTION) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n  }\n  return result;\n}\n\n/* Convert a packed value value */\nSWIGRUNTIME int\nSWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {\n  swig_cast_info *tc;\n  const char *c = 0;\n\n#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)\n  c = PySwigPacked_UnpackData(obj, ptr, sz);\n#else\n  if ((!obj) || (!PyString_Check(obj))) goto type_error;\n  c = PyString_AS_STRING(obj);\n  /* Pointer values must start with leading underscore */\n  c = SWIG_UnpackDataName(c, ptr, sz, ty->name);\n#endif\n  if (!c) goto type_error;\n  if (ty) {\n    tc = SWIG_TypeCheck(c,ty);\n    if (!tc) goto type_error;\n  }\n  return 0;\n\ntype_error:\n  PyErr_Clear();\n  if (flags & SWIG_POINTER_EXCEPTION) {\n    if (ty) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n    } else {\n      SWIG_Python_TypeError("C/C++ packed data", obj);\n    }\n  }\n  return -1;\n}\n\n/* Create a new array object */\nSWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {\n  PyObject *robj = 0;\n  if (!type) {\n    if (!PyErr_Occurred()) {\n      PyErr_Format(PyExc_TypeError, "Swig: null type passed to NewPointerObj");\n    }\n    return robj;\n  }\n  if (!ptr) {\n    Py_INCREF(Py_None);\n    return Py_None;\n  }\n#ifdef SWIG_COBJECT_TYPES\n  robj = PySwigObject_FromVoidPtrAndDesc((void *) ptr, (char *)type->name);\n#else\n  {\n    char result[SWIG_BUFFER_SIZE];\n    robj = SWIG_PackVoidPtr(result, ptr, type->name, sizeof(result)) ?\n      PyString_FromString(result) : 0;\n  }\n#endif\n  if (!robj || (robj == Py_None)) return robj;\n  if (type->clientdata) {\n    PyObject *inst;\n    PyObject *args = Py_BuildValue((char*)"(O)", robj);\n    Py_DECREF(robj);\n    inst = PyObject_CallObject((PyObject *) type->clientdata, args);\n    Py_DECREF(args);\n    if (inst) {\n      if (own) {\n        PyObject_SetAttrString(inst,(char*)"thisown",Py_True);\n      }\n      robj = inst;\n    }\n  }\n  return robj;\n}\n\nSWIGRUNTIME PyObject *\nSWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {\n  PyObject *robj = 0;\n  if (!ptr) {\n    Py_INCREF(Py_None);\n    return Py_None;\n  }\n#if defined(SWIG_COBJECT_TYPES) && !defined(SWIG_COBJECT_PYTHON)\n  robj = PySwigPacked_FromDataAndDesc((void *) ptr, sz, (char *)type->name);\n#else\n  {\n    char result[SWIG_BUFFER_SIZE];\n    robj = SWIG_PackDataName(result, ptr, sz, type->name, sizeof(result)) ?\n      PyString_FromString(result) : 0;\n  }\n#endif\n  return robj;\n}\n\n/* -----------------------------------------------------------------------------*\n *  Get type list\n * -----------------------------------------------------------------------------*/\n\n#ifdef SWIG_LINK_RUNTIME\nvoid *SWIG_ReturnGlobalTypeList(void *);\n#endif\n\nSWIGRUNTIME swig_module_info *\nSWIG_Python_GetModule(void) {\n  static void *type_pointer = (void *)0;\n  /* first check if module already created */\n  if (!type_pointer) {\n#ifdef SWIG_LINK_RUNTIME\n    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);\n#else\n    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,\n                                    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);\n    if (PyErr_Occurred()) {\n      PyErr_Clear();\n      type_pointer = (void *)0;\n    }\n  }\n#endif\n  return (swig_module_info *) type_pointer;\n}\n\nSWIGRUNTIME void\nSWIG_Python_SetModule(swig_module_info *swig_module) {\n  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */\n\n  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,\n                                   swig_empty_runtime_method_table);\n  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, NULL);\n  if (pointer && module) {\n    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n/* -----------------------------------------------------------------------------*\n   Standard SWIG API for use inside user code.\n\n   Don\'t include this file directly, run the command\n   swig -python -external-runtime\n   Also, read the Modules chapter of the SWIG Manual.\n\n * -----------------------------------------------------------------------------*/\n\n#ifdef SWIG_MODULE_CLIENTDATA_TYPE\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_TypeQuery(SWIG_MODULE_CLIENTDATA_TYPE clientdata, const char *name) {\n  swig_module_info *module = SWIG_GetModule(clientdata);\n  return SWIG_TypeQueryModule(module, module, name);\n}\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_MangledTypeQuery(SWIG_MODULE_CLIENTDATA_TYPE clientdata, const char *name) {\n  swig_module_info *module = SWIG_GetModule(clientdata);\n  return SWIG_MangledTypeQueryModule(module, module, name);\n}\n\n#else\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_TypeQuery(const char *name) {\n  swig_module_info *module = SWIG_GetModule();\n  return SWIG_TypeQueryModule(module, module, name);\n}\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_MangledTypeQuery(const char *name) {\n  swig_module_info *module = SWIG_GetModule();\n  return SWIG_MangledTypeQueryModule(module, module, name);\n}\n\n#endif\n\n\n'
swigptr2_code_v3 = '\n/* ----------------------------------------------------------------------------\n * This file was automatically generated by SWIG (http://www.swig.org).\n * Version 1.3.30\n *\n * This file is not intended to be easily readable and contains a number of\n * coding conventions designed to improve portability and efficiency. Do not make\n * changes to this file unless you know what you are doing--modify the SWIG\n * interface file instead.\n * ----------------------------------------------------------------------------- */\n\n/* -----------------------------------------------------------------------------\n *  This section contains generic SWIG labels for method/variable\n *  declarations/attributes, and other compiler dependent labels.\n * ----------------------------------------------------------------------------- */\n\n/* template workaround for compilers that cannot correctly implement the C++ standard */\n#ifndef SWIGTEMPLATEDISAMBIGUATOR\n# if defined(__SUNPRO_CC)\n#   if (__SUNPRO_CC <= 0x560)\n#     define SWIGTEMPLATEDISAMBIGUATOR template\n#   else\n#     define SWIGTEMPLATEDISAMBIGUATOR\n#   endif\n# else\n#   define SWIGTEMPLATEDISAMBIGUATOR\n# endif\n#endif\n\n/* inline attribute */\n#ifndef SWIGINLINE\n# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))\n#   define SWIGINLINE inline\n# else\n#   define SWIGINLINE\n# endif\n#endif\n\n/* attribute recognised by some compilers to avoid \'unused\' warnings */\n#ifndef SWIGUNUSED\n# if defined(__GNUC__)\n#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n#     define SWIGUNUSED __attribute__ ((__unused__))\n#   else\n#     define SWIGUNUSED\n#   endif\n# elif defined(__ICC)\n#   define SWIGUNUSED __attribute__ ((__unused__))\n# else\n#   define SWIGUNUSED\n# endif\n#endif\n\n#ifndef SWIGUNUSEDPARM\n# ifdef __cplusplus\n#   define SWIGUNUSEDPARM(p)\n# else\n#   define SWIGUNUSEDPARM(p) p SWIGUNUSED\n# endif\n#endif\n\n/* internal SWIG method */\n#ifndef SWIGINTERN\n# define SWIGINTERN static SWIGUNUSED\n#endif\n\n/* internal inline SWIG method */\n#ifndef SWIGINTERNINLINE\n# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE\n#endif\n\n/* exporting methods */\n#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n#  ifndef GCC_HASCLASSVISIBILITY\n#    define GCC_HASCLASSVISIBILITY\n#  endif\n#endif\n\n#ifndef SWIGEXPORT\n# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n#   if defined(STATIC_LINKED)\n#     define SWIGEXPORT\n#   else\n#     define SWIGEXPORT __declspec(dllexport)\n#   endif\n# else\n#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)\n#     define SWIGEXPORT __attribute__ ((visibility("default")))\n#   else\n#     define SWIGEXPORT\n#   endif\n# endif\n#endif\n\n/* calling conventions for Windows */\n#ifndef SWIGSTDCALL\n# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n#   define SWIGSTDCALL __stdcall\n# else\n#   define SWIGSTDCALL\n# endif\n#endif\n\n/* Deal with Microsoft\'s attempt at deprecating C standard runtime functions */\n#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)\n# define _CRT_SECURE_NO_DEPRECATE\n#endif\n/*  Errors in SWIG */\n#define  SWIG_UnknownError         -1\n#define  SWIG_IOError              -2\n#define  SWIG_RuntimeError         -3\n#define  SWIG_IndexError           -4\n#define  SWIG_TypeError            -5\n#define  SWIG_DivisionByZero       -6\n#define  SWIG_OverflowError        -7\n#define  SWIG_SyntaxError          -8\n#define  SWIG_ValueError           -9\n#define  SWIG_SystemError          -10\n#define  SWIG_AttributeError       -11\n#define  SWIG_MemoryError          -12\n#define  SWIG_NullReferenceError   -13\n\n\n/*  Errors in SWIG */\n#define  SWIG_UnknownError         -1\n#define  SWIG_IOError              -2\n#define  SWIG_RuntimeError         -3\n#define  SWIG_IndexError           -4\n#define  SWIG_TypeError            -5\n#define  SWIG_DivisionByZero       -6\n#define  SWIG_OverflowError        -7\n#define  SWIG_SyntaxError          -8\n#define  SWIG_ValueError           -9\n#define  SWIG_SystemError          -10\n#define  SWIG_AttributeError       -11\n#define  SWIG_MemoryError          -12\n#define  SWIG_NullReferenceError   -13\n\n\n/* -----------------------------------------------------------------------------\n * swigrun.swg\n *\n * This file contains generic CAPI SWIG runtime support for pointer\n * type checking.\n * ----------------------------------------------------------------------------- */\n\n/* This should only be incremented when either the layout of swig_type_info changes,\n   or for whatever reason, the runtime changes incompatibly */\n#define SWIG_RUNTIME_VERSION "3"\n\n/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */\n#ifdef SWIG_TYPE_TABLE\n# define SWIG_QUOTE_STRING(x) #x\n# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)\n# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)\n#else\n# define SWIG_TYPE_TABLE_NAME\n#endif\n\n/*\n  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for\n  creating a static or dynamic library from the swig runtime code.\n  In 99.9% of the cases, swig just needs to declare them as \'static\'.\n\n  But only do this if is strictly necessary, ie, if you have problems\n  with your compiler or so.\n*/\n\n#ifndef SWIGRUNTIME\n# define SWIGRUNTIME SWIGINTERN\n#endif\n\n#ifndef SWIGRUNTIMEINLINE\n# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE\n#endif\n\n/*  Generic buffer size */\n#ifndef SWIG_BUFFER_SIZE\n# define SWIG_BUFFER_SIZE 1024\n#endif\n\n/* Flags for pointer conversions */\n#define SWIG_POINTER_DISOWN        0x1\n\n/* Flags for new pointer objects */\n#define SWIG_POINTER_OWN           0x1\n\n\n/*\n   Flags/methods for returning states.\n\n   The swig conversion methods, as ConvertPtr, return and integer\n   that tells if the conversion was successful or not. And if not,\n   an error code can be returned (see swigerrors.swg for the codes).\n\n   Use the following macros/flags to set or process the returning\n   states.\n\n   In old swig versions, you usually write code as:\n\n     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {\n       // success code\n     } else {\n       //fail code\n     }\n\n   Now you can be more explicit as:\n\n    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);\n    if (SWIG_IsOK(res)) {\n      // success code\n    } else {\n      // fail code\n    }\n\n   that seems to be the same, but now you can also do\n\n    Type *ptr;\n    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);\n    if (SWIG_IsOK(res)) {\n      // success code\n      if (SWIG_IsNewObj(res) {\n        ...\n        delete *ptr;\n      } else {\n        ...\n      }\n    } else {\n      // fail code\n    }\n\n   I.e., now SWIG_ConvertPtr can return new objects and you can\n   identify the case and take care of the deallocation. Of course that\n   requires also to SWIG_ConvertPtr to return new result values, as\n\n      int SWIG_ConvertPtr(obj, ptr,...) {\n        if (<obj is ok>) {\n          if (<need new object>) {\n            *ptr = <ptr to new allocated object>;\n            return SWIG_NEWOBJ;\n          } else {\n            *ptr = <ptr to old object>;\n            return SWIG_OLDOBJ;\n          }\n        } else {\n          return SWIG_BADOBJ;\n        }\n      }\n\n   Of course, returning the plain \'0(success)/-1(fail)\' still works, but you can be\n   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the\n   swig errors code.\n\n   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code\n   allows to return the \'cast rank\', for example, if you have this\n\n       int food(double)\n       int fooi(int);\n\n   and you call\n\n      food(1)   // cast rank \'1\'  (1 -> 1.0)\n      fooi(1)   // cast rank \'0\'\n\n   just use the SWIG_AddCast()/SWIG_CheckState()\n\n\n */\n#define SWIG_OK                    (0)\n#define SWIG_ERROR                 (-1)\n#define SWIG_IsOK(r)               (r >= 0)\n#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)\n\n/* The CastRankLimit says how many bits are used for the cast rank */\n#define SWIG_CASTRANKLIMIT         (1 << 8)\n/* The NewMask denotes the object was created (using new/malloc) */\n#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)\n/* The TmpMask is for in/out typemaps that use temporal objects */\n#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)\n/* Simple returning values */\n#define SWIG_BADOBJ                (SWIG_ERROR)\n#define SWIG_OLDOBJ                (SWIG_OK)\n#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)\n#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)\n/* Check, add and del mask methods */\n#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)\n#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)\n#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))\n#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)\n#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)\n#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))\n\n\n/* Cast-Rank Mode */\n#if defined(SWIG_CASTRANK_MODE)\n#  ifndef SWIG_TypeRank\n#    define SWIG_TypeRank             unsigned long\n#  endif\n#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */\n#    define SWIG_MAXCASTRANK          (2)\n#  endif\n#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)\n#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)\nSWIGINTERNINLINE int SWIG_AddCast(int r) {\n  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;\n}\nSWIGINTERNINLINE int SWIG_CheckState(int r) {\n  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;\n}\n#else /* no cast-rank mode */\n#  define SWIG_AddCast\n#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)\n#endif\n\n\n\n\n#include <string.h>\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\ntypedef void *(*swig_converter_func)(void *);\ntypedef struct swig_type_info *(*swig_dycast_func)(void **);\n\n/* Structure to store inforomation on one type */\ntypedef struct swig_type_info {\n  const char             *name;                 /* mangled name of this type */\n  const char             *str;                  /* human readable name of this type */\n  swig_dycast_func        dcast;                /* dynamic cast function down a hierarchy */\n  struct swig_cast_info  *cast;                 /* linked list of types that can cast into this type */\n  void                   *clientdata;           /* language specific type data */\n  int                    owndata;               /* flag if the structure owns the clientdata */\n} swig_type_info;\n\n/* Structure to store a type and conversion function used for casting */\ntypedef struct swig_cast_info {\n  swig_type_info         *type;                 /* pointer to type that is equivalent to this type */\n  swig_converter_func     converter;            /* function to cast the void pointers */\n  struct swig_cast_info  *next;                 /* pointer to next cast in linked list */\n  struct swig_cast_info  *prev;                 /* pointer to the previous cast */\n} swig_cast_info;\n\n/* Structure used to store module information\n * Each module generates one structure like this, and the runtime collects\n * all of these structures and stores them in a circularly linked list.*/\ntypedef struct swig_module_info {\n  swig_type_info         **types;               /* Array of pointers to swig_type_info structures that are in this module */\n  size_t                 size;                  /* Number of types in this module */\n  struct swig_module_info *next;                /* Pointer to next element in circularly linked list */\n  swig_type_info         **type_initial;        /* Array of initially generated type structures */\n  swig_cast_info         **cast_initial;        /* Array of initially generated casting structures */\n  void                    *clientdata;          /* Language specific module data */\n} swig_module_info;\n\n/*\n  Compare two type names skipping the space characters, therefore\n  "char*" == "char *" and "Class<int>" == "Class<int >", etc.\n\n  Return 0 when the two name types are equivalent, as in\n  strncmp, but skipping \' \'.\n*/\nSWIGRUNTIME int\nSWIG_TypeNameComp(const char *f1, const char *l1,\n                  const char *f2, const char *l2) {\n  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {\n    while ((*f1 == \' \') && (f1 != l1)) ++f1;\n    while ((*f2 == \' \') && (f2 != l2)) ++f2;\n    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;\n  }\n  return (l1 - f1) - (l2 - f2);\n}\n\n/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if not equal, 1 if equal\n*/\nSWIGRUNTIME int\nSWIG_TypeEquiv(const char *nb, const char *tb) {\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == \'|\') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}\n\n/*\n  Check type equivalence in a name list like <name1>|<name2>|...\n  Return 0 if equal, -1 if nb < tb, 1 if nb > tb\n*/\nSWIGRUNTIME int\nSWIG_TypeCompare(const char *nb, const char *tb) {\n  int equiv = 0;\n  const char* te = tb + strlen(tb);\n  const char* ne = nb;\n  while (!equiv && *ne) {\n    for (nb = ne; *ne; ++ne) {\n      if (*ne == \'|\') break;\n    }\n    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;\n    if (*ne) ++ne;\n  }\n  return equiv;\n}\n\n\n/* think of this as a c++ template<> or a scheme macro */\n#define SWIG_TypeCheck_Template(comparison, ty)           if (ty) {                                                 swig_cast_info *iter = ty->cast;                        while (iter) {                                            if (comparison) {                                         if (iter == ty->cast) return iter;                      /* Move iter to the top of the linked list */           iter->prev->next = iter->next;                          if (iter->next)                                           iter->next->prev = iter->prev;                        iter->next = ty->cast;                                  iter->prev = 0;                                         if (ty->cast) ty->cast->prev = iter;                    ty->cast = iter;                                        return iter;                                          }                                                       iter = iter->next;                                    }                                                     }                                                       return 0\n\n/*\n  Check the typename\n*/\nSWIGRUNTIME swig_cast_info *\nSWIG_TypeCheck(const char *c, swig_type_info *ty) {\n  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);\n}\n\n/* Same as previous function, except strcmp is replaced with a pointer comparison */\nSWIGRUNTIME swig_cast_info *\nSWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {\n  SWIG_TypeCheck_Template(iter->type == from, into);\n}\n\n/*\n  Cast a pointer up an inheritance hierarchy\n*/\nSWIGRUNTIMEINLINE void *\nSWIG_TypeCast(swig_cast_info *ty, void *ptr) {\n  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);\n}\n\n/*\n   Dynamic pointer casting. Down an inheritance hierarchy\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {\n  swig_type_info *lastty = ty;\n  if (!ty || !ty->dcast) return ty;\n  while (ty && (ty->dcast)) {\n    ty = (*ty->dcast)(ptr);\n    if (ty) lastty = ty;\n  }\n  return lastty;\n}\n\n/*\n  Return the name associated with this type\n*/\nSWIGRUNTIMEINLINE const char *\nSWIG_TypeName(const swig_type_info *ty) {\n  return ty->name;\n}\n\n/*\n  Return the pretty name associated with this type,\n  that is an unmangled type name in a form presentable to the user.\n*/\nSWIGRUNTIME const char *\nSWIG_TypePrettyName(const swig_type_info *type) {\n  /* The "str" field contains the equivalent pretty names of the\n     type, separated by vertical-bar characters.  We choose\n     to print the last name, as it is often (?) the most\n     specific. */\n  if (!type) return NULL;\n  if (type->str != NULL) {\n    const char *last_name = type->str;\n    const char *s;\n    for (s = type->str; *s; s++)\n      if (*s == \'|\') last_name = s+1;\n    return last_name;\n  }\n  else\n    return type->name;\n}\n\n/*\n   Set the clientdata field for a type\n*/\nSWIGRUNTIME void\nSWIG_TypeClientData(swig_type_info *ti, void *clientdata) {\n  swig_cast_info *cast = ti->cast;\n  /* if (ti->clientdata == clientdata) return; */\n  ti->clientdata = clientdata;\n\n  while (cast) {\n    if (!cast->converter) {\n      swig_type_info *tc = cast->type;\n      if (!tc->clientdata) {\n        SWIG_TypeClientData(tc, clientdata);\n      }\n    }\n    cast = cast->next;\n  }\n}\nSWIGRUNTIME void\nSWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {\n  SWIG_TypeClientData(ti, clientdata);\n  ti->owndata = 1;\n}\n\n/*\n  Search for a swig_type_info structure only by mangled name\n  Search is a O(log #types)\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_MangledTypeQueryModule(swig_module_info *start,\n                            swig_module_info *end,\n                            const char *name) {\n  swig_module_info *iter = start;\n  do {\n    if (iter->size) {\n      register size_t l = 0;\n      register size_t r = iter->size - 1;\n      do {\n        /* since l+r >= 0, we can (>> 1) instead (/ 2) */\n        register size_t i = (l + r) >> 1;\n        const char *iname = iter->types[i]->name;\n        if (iname) {\n          register int compare = strcmp(name, iname);\n          if (compare == 0) {\n            return iter->types[i];\n          } else if (compare < 0) {\n            if (i) {\n              r = i - 1;\n            } else {\n              break;\n            }\n          } else if (compare > 0) {\n            l = i + 1;\n          }\n        } else {\n          break; /* should never happen */\n        }\n      } while (l <= r);\n    }\n    iter = iter->next;\n  } while (iter != end);\n  return 0;\n}\n\n/*\n  Search for a swig_type_info structure for either a mangled name or a human readable name.\n  It first searches the mangled names of the types, which is a O(log #types)\n  If a type is not found it then searches the human readable names, which is O(#types).\n\n  We start searching at module start, and finish searching when start == end.\n  Note: if start == end at the beginning of the function, we go all the way around\n  the circular list.\n*/\nSWIGRUNTIME swig_type_info *\nSWIG_TypeQueryModule(swig_module_info *start,\n                     swig_module_info *end,\n                     const char *name) {\n  /* STEP 1: Search the name field using binary search */\n  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);\n  if (ret) {\n    return ret;\n  } else {\n    /* STEP 2: If the type hasn\'t been found, do a complete search\n       of the str field (the human readable name) */\n    swig_module_info *iter = start;\n    do {\n      register size_t i = 0;\n      for (; i < iter->size; ++i) {\n        if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))\n          return iter->types[i];\n      }\n      iter = iter->next;\n    } while (iter != end);\n  }\n\n  /* neither found a match */\n  return 0;\n}\n\n/*\n   Pack binary data into a string\n*/\nSWIGRUNTIME char *\nSWIG_PackData(char *c, void *ptr, size_t sz) {\n  static const char hex[17] = "0123456789abcdef";\n  register const unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu =  u + sz;\n  for (; u != eu; ++u) {\n    register unsigned char uu = *u;\n    *(c++) = hex[(uu & 0xf0) >> 4];\n    *(c++) = hex[uu & 0xf];\n  }\n  return c;\n}\n\n/*\n   Unpack binary data from a string\n*/\nSWIGRUNTIME const char *\nSWIG_UnpackData(const char *c, void *ptr, size_t sz) {\n  register unsigned char *u = (unsigned char *) ptr;\n  register const unsigned char *eu = u + sz;\n  for (; u != eu; ++u) {\n    register char d = *(c++);\n    register unsigned char uu;\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu = ((d - \'0\') << 4);\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu = ((d - (\'a\'-10)) << 4);\n    else\n      return (char *) 0;\n    d = *(c++);\n    if ((d >= \'0\') && (d <= \'9\'))\n      uu |= (d - \'0\');\n    else if ((d >= \'a\') && (d <= \'f\'))\n      uu |= (d - (\'a\'-10));\n    else\n      return (char *) 0;\n    *u = uu;\n  }\n  return c;\n}\n\n/*\n   Pack \'void *\' into a string buffer.\n*/\nSWIGRUNTIME char *\nSWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {\n  char *r = buff;\n  if ((2*sizeof(void *) + 2) > bsz) return 0;\n  *(r++) = \'_\';\n  r = SWIG_PackData(r,&ptr,sizeof(void *));\n  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;\n  strcpy(r,name);\n  return buff;\n}\n\nSWIGRUNTIME const char *\nSWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {\n  if (*c != \'_\') {\n    if (strcmp(c,"NULL") == 0) {\n      *ptr = (void *) 0;\n      return name;\n    } else {\n      return 0;\n    }\n  }\n  return SWIG_UnpackData(++c,ptr,sizeof(void *));\n}\n\nSWIGRUNTIME char *\nSWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {\n  char *r = buff;\n  size_t lname = (name ? strlen(name) : 0);\n  if ((2*sz + 2 + lname) > bsz) return 0;\n  *(r++) = \'_\';\n  r = SWIG_PackData(r,ptr,sz);\n  if (lname) {\n    strncpy(r,name,lname+1);\n  } else {\n    *r = 0;\n  }\n  return buff;\n}\n\nSWIGRUNTIME const char *\nSWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {\n  if (*c != \'_\') {\n    if (strcmp(c,"NULL") == 0) {\n      memset(ptr,0,sz);\n      return name;\n    } else {\n      return 0;\n    }\n  }\n  return SWIG_UnpackData(++c,ptr,sz);\n}\n\n#ifdef __cplusplus\n}\n#endif\n/* Python.h has to appear first */\n#include <Python.h>\n\n/* Add PyOS_snprintf for old Pythons */\n#if PY_VERSION_HEX < 0x02020000\n# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)\n#  define PyOS_snprintf _snprintf\n# else\n#  define PyOS_snprintf snprintf\n# endif\n#endif\n\n/* A crude PyString_FromFormat implementation for old Pythons */\n#if PY_VERSION_HEX < 0x02020000\n\n#ifndef SWIG_PYBUFFER_SIZE\n# define SWIG_PYBUFFER_SIZE 1024\n#endif\n\nstatic PyObject *\nPyString_FromFormat(const char *fmt, ...) {\n  va_list ap;\n  char buf[SWIG_PYBUFFER_SIZE * 2];\n  int res;\n  va_start(ap, fmt);\n  res = vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);\n}\n#endif\n\n/* Add PyObject_Del for old Pythons */\n#if PY_VERSION_HEX < 0x01060000\n# define PyObject_Del(op) PyMem_DEL((op))\n#endif\n#ifndef PyObject_DEL\n# define PyObject_DEL PyObject_Del\n#endif\n\n/* A crude PyExc_StopIteration exception for old Pythons */\n#if PY_VERSION_HEX < 0x02020000\n# ifndef PyExc_StopIteration\n#  define PyExc_StopIteration PyExc_RuntimeError\n# endif\n# ifndef PyObject_GenericGetAttr\n#  define PyObject_GenericGetAttr 0\n# endif\n#endif\n/* Py_NotImplemented is defined in 2.1 and up. */\n#if PY_VERSION_HEX < 0x02010000\n# ifndef Py_NotImplemented\n#  define Py_NotImplemented PyExc_RuntimeError\n# endif\n#endif\n\n\n/* A crude PyString_AsStringAndSize implementation for old Pythons */\n#if PY_VERSION_HEX < 0x02010000\n# ifndef PyString_AsStringAndSize\n#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}\n# endif\n#endif\n\n/* PySequence_Size for old Pythons */\n#if PY_VERSION_HEX < 0x02000000\n# ifndef PySequence_Size\n#  define PySequence_Size PySequence_Length\n# endif\n#endif\n\n\n/* PyBool_FromLong for old Pythons */\n#if PY_VERSION_HEX < 0x02030000\nstatic\nPyObject *PyBool_FromLong(long ok)\n{\n  PyObject *result = ok ? Py_True : Py_False;\n  Py_INCREF(result);\n  return result;\n}\n#endif\n\n/* -----------------------------------------------------------------------------\n * error manipulation\n * ----------------------------------------------------------------------------- */\n\nSWIGRUNTIME PyObject*\nSWIG_Python_ErrorType(int code) {\n  PyObject* type = 0;\n  switch(code) {\n  case SWIG_MemoryError:\n    type = PyExc_MemoryError;\n    break;\n  case SWIG_IOError:\n    type = PyExc_IOError;\n    break;\n  case SWIG_RuntimeError:\n    type = PyExc_RuntimeError;\n    break;\n  case SWIG_IndexError:\n    type = PyExc_IndexError;\n    break;\n  case SWIG_TypeError:\n    type = PyExc_TypeError;\n    break;\n  case SWIG_DivisionByZero:\n    type = PyExc_ZeroDivisionError;\n    break;\n  case SWIG_OverflowError:\n    type = PyExc_OverflowError;\n    break;\n  case SWIG_SyntaxError:\n    type = PyExc_SyntaxError;\n    break;\n  case SWIG_ValueError:\n    type = PyExc_ValueError;\n    break;\n  case SWIG_SystemError:\n    type = PyExc_SystemError;\n    break;\n  case SWIG_AttributeError:\n    type = PyExc_AttributeError;\n    break;\n  default:\n    type = PyExc_RuntimeError;\n  }\n  return type;\n}\n\n\nSWIGRUNTIME void\nSWIG_Python_AddErrorMsg(const char* mesg)\n{\n  PyObject *type = 0;\n  PyObject *value = 0;\n  PyObject *traceback = 0;\n\n  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);\n  if (value) {\n    PyObject *old_str = PyObject_Str(value);\n    PyErr_Clear();\n    Py_XINCREF(type);\n    PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);\n    Py_DECREF(old_str);\n    Py_DECREF(value);\n  } else {\n    PyErr_Format(PyExc_RuntimeError, mesg);\n  }\n}\n\n\n#if defined(SWIG_PYTHON_NO_THREADS)\n#  if defined(SWIG_PYTHON_THREADS)\n#    undef SWIG_PYTHON_THREADS\n#  endif\n#endif\n#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */\n#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)\n#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */\n#      define SWIG_PYTHON_USE_GIL\n#    endif\n#  endif\n#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */\n#    ifndef SWIG_PYTHON_INITIALIZE_THREADS\n#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads()\n#    endif\n#    ifdef __cplusplus /* C++ code */\n       class SWIG_Python_Thread_Block {\n         bool status;\n         PyGILState_STATE state;\n       public:\n         void end() { if (status) { PyGILState_Release(state); status = false;} }\n         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}\n         ~SWIG_Python_Thread_Block() { end(); }\n       };\n       class SWIG_Python_Thread_Allow {\n         bool status;\n         PyThreadState *save;\n       public:\n         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}\n         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}\n         ~SWIG_Python_Thread_Allow() { end(); }\n       };\n#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block\n#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()\n#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow\n#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()\n#    else /* C code */\n#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()\n#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)\n#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()\n#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)\n#    endif\n#  else /* Old thread way, not implemented, user must provide it */\n#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)\n#      define SWIG_PYTHON_INITIALIZE_THREADS\n#    endif\n#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)\n#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK\n#    endif\n#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)\n#      define SWIG_PYTHON_THREAD_END_BLOCK\n#    endif\n#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)\n#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW\n#    endif\n#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)\n#      define SWIG_PYTHON_THREAD_END_ALLOW\n#    endif\n#  endif\n#else /* No thread support */\n#  define SWIG_PYTHON_INITIALIZE_THREADS\n#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK\n#  define SWIG_PYTHON_THREAD_END_BLOCK\n#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW\n#  define SWIG_PYTHON_THREAD_END_ALLOW\n#endif\n/* -----------------------------------------------------------------------------\n * Python API portion that goes into the runtime\n * ----------------------------------------------------------------------------- */\n\n#ifdef __cplusplus\nextern "C" {\n#if 0\n} /* cc-mode */\n#endif\n#endif\n\n/* -----------------------------------------------------------------------------\n * Constant declarations\n * ----------------------------------------------------------------------------- */\n\n/* Constant Types */\n#define SWIG_PY_POINTER 4\n#define SWIG_PY_BINARY  5\n\n/* Constant information structure */\ntypedef struct swig_const_info {\n  int type;\n  char *name;\n  long lvalue;\n  double dvalue;\n  void   *pvalue;\n  swig_type_info **ptype;\n} swig_const_info;\n\n#ifdef __cplusplus\n#if 0\n{ /* cc-mode */\n#endif\n}\n#endif\n\n/* -----------------------------------------------------------------------------\n * See the LICENSE file for information on copyright, usage and redistribution\n * of SWIG, and the README file for authors - http://www.swig.org/release.html.\n *\n * pyrun.swg\n *\n * This file contains the runtime support for Python modules\n * and includes code for managing global variables and pointer\n * type checking.\n *\n * ----------------------------------------------------------------------------- */\n\n/* Common SWIG API */\n\n/* for raw pointers */\n#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)\n#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)\n#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)\n#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(ptr, type, flags)\n#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty)\n#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)\n#define swig_owntype                                    int\n\n/* for raw packed data */\n#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)\n#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)\n\n/* for class or struct pointers */\n#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)\n#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)\n\n/* for C or C++ function pointers */\n#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)\n#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(ptr, type, 0)\n\n/* for C++ member pointers, ie, member methods */\n#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)\n#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)\n\n\n/* Runtime API */\n\n#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule()\n#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)\n#define SWIG_NewClientData(obj)                         PySwigClientData_New(obj)\n\n#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj\n#define SWIG_SetErrorMsg                                SWIG_Python_SetErrorMsg\n#define SWIG_ErrorType(code)                            SWIG_Python_ErrorType(code)\n#define SWIG_Error(code, msg)                           SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg)\n#define SWIG_fail                                       goto fail\n\n\n/* Runtime API implementation */\n\n/* Error manipulation */\n\nSWIGINTERN void\nSWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {\n  SWIG_PYTHON_THREAD_BEGIN_BLOCK;\n  PyErr_SetObject(errtype, obj);\n  Py_DECREF(obj);\n  SWIG_PYTHON_THREAD_END_BLOCK;\n}\n\nSWIGINTERN void\nSWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {\n  SWIG_PYTHON_THREAD_BEGIN_BLOCK;\n  PyErr_SetString(errtype, (char *) msg);\n  SWIG_PYTHON_THREAD_END_BLOCK;\n}\n\n#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)\n\n/* Set a constant value */\n\nSWIGINTERN void\nSWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {\n  PyDict_SetItemString(d, (char*) name, obj);\n  Py_DECREF(obj);\n}\n\n/* Append a value to the result obj */\n\nSWIGINTERN PyObject*\nSWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {\n#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)\n  if (!result) {\n    result = obj;\n  } else if (result == Py_None) {\n    Py_DECREF(result);\n    result = obj;\n  } else {\n    if (!PyList_Check(result)) {\n      PyObject *o2 = result;\n      result = PyList_New(1);\n      PyList_SetItem(result, 0, o2);\n    }\n    PyList_Append(result,obj);\n    Py_DECREF(obj);\n  }\n  return result;\n#else\n  PyObject*   o2;\n  PyObject*   o3;\n  if (!result) {\n    result = obj;\n  } else if (result == Py_None) {\n    Py_DECREF(result);\n    result = obj;\n  } else {\n    if (!PyTuple_Check(result)) {\n      o2 = result;\n      result = PyTuple_New(1);\n      PyTuple_SET_ITEM(result, 0, o2);\n    }\n    o3 = PyTuple_New(1);\n    PyTuple_SET_ITEM(o3, 0, obj);\n    o2 = result;\n    result = PySequence_Concat(o2, o3);\n    Py_DECREF(o2);\n    Py_DECREF(o3);\n  }\n  return result;\n#endif\n}\n\n/* Unpack the argument tuple */\n\nSWIGINTERN int\nSWIG_Python_UnpackTuple(PyObject *args, const char *name, int min, int max, PyObject **objs)\n{\n  if (!args) {\n    if (!min && !max) {\n      return 1;\n    } else {\n      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none",\n                   name, (min == max ? "" : "at least "), min);\n      return 0;\n    }\n  }\n  if (!PyTuple_Check(args)) {\n    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");\n    return 0;\n  } else {\n    register int l = PyTuple_GET_SIZE(args);\n    if (l < min) {\n      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d",\n                   name, (min == max ? "" : "at least "), min, l);\n      return 0;\n    } else if (l > max) {\n      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d",\n                   name, (min == max ? "" : "at most "), max, l);\n      return 0;\n    } else {\n      register int i;\n      for (i = 0; i < l; ++i) {\n        objs[i] = PyTuple_GET_ITEM(args, i);\n      }\n      for (; l < max; ++l) {\n        objs[l] = 0;\n      }\n      return i + 1;\n    }\n  }\n}\n\n/* A functor is a function object with one single object argument */\n#if PY_VERSION_HEX >= 0x02020000\n#define SWIG_Python_CallFunctor(functor, obj)           PyObject_CallFunctionObjArgs(functor, obj, NULL);\n#else\n#define SWIG_Python_CallFunctor(functor, obj)           PyObject_CallFunction(functor, "O", obj);\n#endif\n\n/*\n  Helper for static pointer initialization for both C and C++ code, for example\n  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);\n*/\n#ifdef __cplusplus\n#define SWIG_STATIC_POINTER(var)  var\n#else\n#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var\n#endif\n\n/* -----------------------------------------------------------------------------\n * Pointer declarations\n * ----------------------------------------------------------------------------- */\n\n/* Flags for new pointer objects */\n#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)\n#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)\n\n#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)\n\n#ifdef __cplusplus\nextern "C" {\n#if 0\n} /* cc-mode */\n#endif\n#endif\n\n/*  How to access Py_None */\n#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n#  ifndef SWIG_PYTHON_NO_BUILD_NONE\n#    ifndef SWIG_PYTHON_BUILD_NONE\n#      define SWIG_PYTHON_BUILD_NONE\n#    endif\n#  endif\n#endif\n\n#ifdef SWIG_PYTHON_BUILD_NONE\n#  ifdef Py_None\n#   undef Py_None\n#   define Py_None SWIG_Py_None()\n#  endif\nSWIGRUNTIMEINLINE PyObject *\n_SWIG_Py_None(void)\n{\n  PyObject *none = Py_BuildValue((char*)"");\n  Py_DECREF(none);\n  return none;\n}\nSWIGRUNTIME PyObject *\nSWIG_Py_None(void)\n{\n  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();\n  return none;\n}\n#endif\n\n/* The python void return value */\n\nSWIGRUNTIMEINLINE PyObject *\nSWIG_Py_Void(void)\n{\n  PyObject *none = Py_None;\n  Py_INCREF(none);\n  return none;\n}\n\n/* PySwigClientData */\n\ntypedef struct {\n  PyObject *klass;\n  PyObject *newraw;\n  PyObject *newargs;\n  PyObject *destroy;\n  int delargs;\n  int implicitconv;\n} PySwigClientData;\n\nSWIGRUNTIMEINLINE int\nSWIG_Python_CheckImplicit(swig_type_info *ty)\n{\n  PySwigClientData *data = (PySwigClientData *)ty->clientdata;\n  return data ? data->implicitconv : 0;\n}\n\nSWIGRUNTIMEINLINE PyObject *\nSWIG_Python_ExceptionType(swig_type_info *desc) {\n  PySwigClientData *data = desc ? (PySwigClientData *) desc->clientdata : 0;\n  PyObject *klass = data ? data->klass : 0;\n  return (klass ? klass : PyExc_RuntimeError);\n}\n\n\nSWIGRUNTIME PySwigClientData *\nPySwigClientData_New(PyObject* obj)\n{\n  if (!obj) {\n    return 0;\n  } else {\n    PySwigClientData *data = (PySwigClientData *)malloc(sizeof(PySwigClientData));\n    /* the klass element */\n    data->klass = obj;\n    Py_INCREF(data->klass);\n    /* the newraw method and newargs arguments used to create a new raw instance */\n    if (PyClass_Check(obj)) {\n      data->newraw = 0;\n      data->newargs = obj;\n      Py_INCREF(obj);\n    } else {\n#if (PY_VERSION_HEX < 0x02020000)\n      data->newraw = 0;\n#else\n      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");\n#endif\n      if (data->newraw) {\n        Py_INCREF(data->newraw);\n        data->newargs = PyTuple_New(1);\n        PyTuple_SetItem(data->newargs, 0, obj);\n      } else {\n        data->newargs = obj;\n      }\n      Py_INCREF(data->newargs);\n    }\n    /* the destroy method, aka as the C++ delete method */\n    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");\n    if (PyErr_Occurred()) {\n      PyErr_Clear();\n      data->destroy = 0;\n    }\n    if (data->destroy) {\n      int flags;\n      Py_INCREF(data->destroy);\n      flags = PyCFunction_GET_FLAGS(data->destroy);\n#ifdef METH_O\n      data->delargs = !(flags & (METH_O));\n#else\n      data->delargs = 0;\n#endif\n    } else {\n      data->delargs = 0;\n    }\n    data->implicitconv = 0;\n    return data;\n  }\n}\n\nSWIGRUNTIME void\nPySwigClientData_Del(PySwigClientData* data)\n{\n  Py_XDECREF(data->newraw);\n  Py_XDECREF(data->newargs);\n  Py_XDECREF(data->destroy);\n}\n\n/* =============== PySwigObject =====================*/\n\ntypedef struct {\n  PyObject_HEAD\n  void *ptr;\n  swig_type_info *ty;\n  int own;\n  PyObject *next;\n} PySwigObject;\n\nSWIGRUNTIME PyObject *\nPySwigObject_long(PySwigObject *v)\n{\n  return PyLong_FromVoidPtr(v->ptr);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_format(const char* fmt, PySwigObject *v)\n{\n  PyObject *res = NULL;\n  PyObject *args = PyTuple_New(1);\n  if (args) {\n    if (PyTuple_SetItem(args, 0, PySwigObject_long(v)) == 0) {\n      PyObject *ofmt = PyString_FromString(fmt);\n      if (ofmt) {\n        res = PyString_Format(ofmt,args);\n        Py_DECREF(ofmt);\n      }\n      Py_DECREF(args);\n    }\n  }\n  return res;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_oct(PySwigObject *v)\n{\n  return PySwigObject_format("%o",v);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_hex(PySwigObject *v)\n{\n  return PySwigObject_format("%x",v);\n}\n\nSWIGRUNTIME PyObject *\n#ifdef METH_NOARGS\nPySwigObject_repr(PySwigObject *v)\n#else\nPySwigObject_repr(PySwigObject *v, PyObject *args)\n#endif\n{\n  const char *name = SWIG_TypePrettyName(v->ty);\n  PyObject *hex = PySwigObject_hex(v);\n  PyObject *repr = PyString_FromFormat("<Swig Object of type \'%s\' at 0x%s>", name, PyString_AsString(hex));\n  Py_DECREF(hex);\n  if (v->next) {\n#ifdef METH_NOARGS\n    PyObject *nrep = PySwigObject_repr((PySwigObject *)v->next);\n#else\n    PyObject *nrep = PySwigObject_repr((PySwigObject *)v->next, args);\n#endif\n    PyString_ConcatAndDel(&repr,nrep);\n  }\n  return repr;\n}\n\nSWIGRUNTIME int\nPySwigObject_print(PySwigObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))\n{\n#ifdef METH_NOARGS\n  PyObject *repr = PySwigObject_repr(v);\n#else\n  PyObject *repr = PySwigObject_repr(v, NULL);\n#endif\n  if (repr) {\n    fputs(PyString_AsString(repr), fp);\n    Py_DECREF(repr);\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_str(PySwigObject *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?\n    PyString_FromString(result) : 0;\n}\n\nSWIGRUNTIME int\nPySwigObject_compare(PySwigObject *v, PySwigObject *w)\n{\n  void *i = v->ptr;\n  void *j = w->ptr;\n  return (i < j) ? -1 : ((i > j) ? 1 : 0);\n}\n\nSWIGRUNTIME PyTypeObject* _PySwigObject_type(void);\n\nSWIGRUNTIME PyTypeObject*\nPySwigObject_type(void) {\n  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigObject_type();\n  return type;\n}\n\nSWIGRUNTIMEINLINE int\nPySwigObject_Check(PyObject *op) {\n  return ((op)->ob_type == PySwigObject_type())\n    || (strcmp((op)->ob_type->tp_name,"PySwigObject") == 0);\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_New(void *ptr, swig_type_info *ty, int own);\n\nSWIGRUNTIME void\nPySwigObject_dealloc(PyObject *v)\n{\n  PySwigObject *sobj = (PySwigObject *) v;\n  PyObject *next = sobj->next;\n  if (sobj->own) {\n    swig_type_info *ty = sobj->ty;\n    PySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;\n    PyObject *destroy = data ? data->destroy : 0;\n    if (destroy) {\n      /* destroy is always a VARARGS method */\n      PyObject *res;\n      if (data->delargs) {\n        /* we need to create a temporal object to carry the destroy operation */\n        PyObject *tmp = PySwigObject_New(sobj->ptr, ty, 0);\n        res = SWIG_Python_CallFunctor(destroy, tmp);\n        Py_DECREF(tmp);\n      } else {\n        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);\n        PyObject *mself = PyCFunction_GET_SELF(destroy);\n        res = ((*meth)(mself, v));\n      }\n      Py_XDECREF(res);\n    } else {\n      const char *name = SWIG_TypePrettyName(ty);\n#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)\n      printf("swig/python detected a memory leak of type \'%s\', no destructor found.\\n", name);\n#endif\n    }\n  }\n  Py_XDECREF(next);\n  PyObject_DEL(v);\n}\n\nSWIGRUNTIME PyObject*\nPySwigObject_append(PyObject* v, PyObject* next)\n{\n  PySwigObject *sobj = (PySwigObject *) v;\n#ifndef METH_O\n  PyObject *tmp = 0;\n  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;\n  next = tmp;\n#endif\n  if (!PySwigObject_Check(next)) {\n    return NULL;\n  }\n  sobj->next = next;\n  Py_INCREF(next);\n  return SWIG_Py_Void();\n}\n\nSWIGRUNTIME PyObject*\n#ifdef METH_NOARGS\nPySwigObject_next(PyObject* v)\n#else\nPySwigObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))\n#endif\n{\n  PySwigObject *sobj = (PySwigObject *) v;\n  if (sobj->next) {\n    Py_INCREF(sobj->next);\n    return sobj->next;\n  } else {\n    return SWIG_Py_Void();\n  }\n}\n\nSWIGINTERN PyObject*\n#ifdef METH_NOARGS\nPySwigObject_disown(PyObject *v)\n#else\nPySwigObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))\n#endif\n{\n  PySwigObject *sobj = (PySwigObject *)v;\n  sobj->own = 0;\n  return SWIG_Py_Void();\n}\n\nSWIGINTERN PyObject*\n#ifdef METH_NOARGS\nPySwigObject_acquire(PyObject *v)\n#else\nPySwigObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))\n#endif\n{\n  PySwigObject *sobj = (PySwigObject *)v;\n  sobj->own = SWIG_POINTER_OWN;\n  return SWIG_Py_Void();\n}\n\nSWIGINTERN PyObject*\nPySwigObject_own(PyObject *v, PyObject *args)\n{\n  PyObject *val = 0;\n#if (PY_VERSION_HEX < 0x02020000)\n  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))\n#else\n  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val))\n#endif\n    {\n      return NULL;\n    }\n  else\n    {\n      PySwigObject *sobj = (PySwigObject *)v;\n      PyObject *obj = PyBool_FromLong(sobj->own);\n      if (val) {\n#ifdef METH_NOARGS\n        if (PyObject_IsTrue(val)) {\n          PySwigObject_acquire(v);\n        } else {\n          PySwigObject_disown(v);\n        }\n#else\n        if (PyObject_IsTrue(val)) {\n          PySwigObject_acquire(v,args);\n        } else {\n          PySwigObject_disown(v,args);\n        }\n#endif\n      }\n      return obj;\n    }\n}\n\n#ifdef METH_O\nstatic PyMethodDef\nswigobject_methods[] = {\n  {(char *)"disown",  (PyCFunction)PySwigObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},\n  {(char *)"acquire", (PyCFunction)PySwigObject_acquire, METH_NOARGS,  (char *)"aquires ownership of the pointer"},\n  {(char *)"own",     (PyCFunction)PySwigObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},\n  {(char *)"append",  (PyCFunction)PySwigObject_append,  METH_O,       (char *)"appends another \'this\' object"},\n  {(char *)"next",    (PyCFunction)PySwigObject_next,    METH_NOARGS,  (char *)"returns the next \'this\' object"},\n  {(char *)"__repr__",(PyCFunction)PySwigObject_repr,    METH_NOARGS,  (char *)"returns object representation"},\n  {0, 0, 0, 0}\n};\n#else\nstatic PyMethodDef\nswigobject_methods[] = {\n  {(char *)"disown",  (PyCFunction)PySwigObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},\n  {(char *)"acquire", (PyCFunction)PySwigObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},\n  {(char *)"own",     (PyCFunction)PySwigObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},\n  {(char *)"append",  (PyCFunction)PySwigObject_append,  METH_VARARGS,  (char *)"appends another \'this\' object"},\n  {(char *)"next",    (PyCFunction)PySwigObject_next,    METH_VARARGS,  (char *)"returns the next \'this\' object"},\n  {(char *)"__repr__",(PyCFunction)PySwigObject_repr,   METH_VARARGS,  (char *)"returns object representation"},\n  {0, 0, 0, 0}\n};\n#endif\n\n#if PY_VERSION_HEX < 0x02020000\nSWIGINTERN PyObject *\nPySwigObject_getattr(PySwigObject *sobj,char *name)\n{\n  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);\n}\n#endif\n\nSWIGRUNTIME PyTypeObject*\n_PySwigObject_type(void) {\n  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";\n\n  static PyNumberMethods PySwigObject_as_number = {\n    (binaryfunc)0, /*nb_add*/\n    (binaryfunc)0, /*nb_subtract*/\n    (binaryfunc)0, /*nb_multiply*/\n    (binaryfunc)0, /*nb_divide*/\n    (binaryfunc)0, /*nb_remainder*/\n    (binaryfunc)0, /*nb_divmod*/\n    (ternaryfunc)0,/*nb_power*/\n    (unaryfunc)0,  /*nb_negative*/\n    (unaryfunc)0,  /*nb_positive*/\n    (unaryfunc)0,  /*nb_absolute*/\n    (inquiry)0,    /*nb_nonzero*/\n    0,             /*nb_invert*/\n    0,             /*nb_lshift*/\n    0,             /*nb_rshift*/\n    0,             /*nb_and*/\n    0,             /*nb_xor*/\n    0,             /*nb_or*/\n    (coercion)0,   /*nb_coerce*/\n    (unaryfunc)PySwigObject_long, /*nb_int*/\n    (unaryfunc)PySwigObject_long, /*nb_long*/\n    (unaryfunc)0,                 /*nb_float*/\n    (unaryfunc)PySwigObject_oct,  /*nb_oct*/\n    (unaryfunc)PySwigObject_hex,  /*nb_hex*/\n#if PY_VERSION_HEX >= 0x02020000\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */\n#elif PY_VERSION_HEX >= 0x02000000\n    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */\n#endif\n  };\n\n  static PyTypeObject pyswigobject_type;\n  static int type_init = 0;\n  if (!type_init) {\n    const PyTypeObject tmp\n      = {\n        PyObject_HEAD_INIT(NULL)\n        0,                                  /* ob_size */\n        (char *)"PySwigObject",             /* tp_name */\n        sizeof(PySwigObject),               /* tp_basicsize */\n        0,                                  /* tp_itemsize */\n        (destructor)PySwigObject_dealloc,   /* tp_dealloc */\n        (printfunc)PySwigObject_print,      /* tp_print */\n#if PY_VERSION_HEX < 0x02020000\n        (getattrfunc)PySwigObject_getattr,  /* tp_getattr */\n#else\n        (getattrfunc)0,                     /* tp_getattr */\n#endif\n        (setattrfunc)0,                     /* tp_setattr */\n        (cmpfunc)PySwigObject_compare,      /* tp_compare */\n        (reprfunc)PySwigObject_repr,        /* tp_repr */\n        &PySwigObject_as_number,            /* tp_as_number */\n        0,                                  /* tp_as_sequence */\n        0,                                  /* tp_as_mapping */\n        (hashfunc)0,                        /* tp_hash */\n        (ternaryfunc)0,                     /* tp_call */\n        (reprfunc)PySwigObject_str,         /* tp_str */\n        PyObject_GenericGetAttr,            /* tp_getattro */\n        0,                                  /* tp_setattro */\n        0,                                  /* tp_as_buffer */\n        Py_TPFLAGS_DEFAULT,                 /* tp_flags */\n        swigobject_doc,                     /* tp_doc */\n        0,                                  /* tp_traverse */\n        0,                                  /* tp_clear */\n        0,                                  /* tp_richcompare */\n        0,                                  /* tp_weaklistoffset */\n#if PY_VERSION_HEX >= 0x02020000\n        0,                                  /* tp_iter */\n        0,                                  /* tp_iternext */\n        swigobject_methods,                 /* tp_methods */\n        0,                                  /* tp_members */\n        0,                                  /* tp_getset */\n        0,                                  /* tp_base */\n        0,                                  /* tp_dict */\n        0,                                  /* tp_descr_get */\n        0,                                  /* tp_descr_set */\n        0,                                  /* tp_dictoffset */\n        0,                                  /* tp_init */\n        0,                                  /* tp_alloc */\n        0,                                  /* tp_new */\n        0,                                  /* tp_free */\n        0,                                  /* tp_is_gc */\n        0,                                  /* tp_bases */\n        0,                                  /* tp_mro */\n        0,                                  /* tp_cache */\n        0,                                  /* tp_subclasses */\n        0,                                  /* tp_weaklist */\n#endif\n#if PY_VERSION_HEX >= 0x02030000\n        0,                                  /* tp_del */\n#endif\n#ifdef COUNT_ALLOCS\n        0,0,0,0                             /* tp_alloc -> tp_next */\n#endif\n      };\n    pyswigobject_type = tmp;\n    pyswigobject_type.ob_type = &PyType_Type;\n    type_init = 1;\n  }\n  return &pyswigobject_type;\n}\n\nSWIGRUNTIME PyObject *\nPySwigObject_New(void *ptr, swig_type_info *ty, int own)\n{\n  PySwigObject *sobj = PyObject_NEW(PySwigObject, PySwigObject_type());\n  if (sobj) {\n    sobj->ptr  = ptr;\n    sobj->ty   = ty;\n    sobj->own  = own;\n    sobj->next = 0;\n  }\n  return (PyObject *)sobj;\n}\n\n/* -----------------------------------------------------------------------------\n * Implements a simple Swig Packed type, and use it instead of string\n * ----------------------------------------------------------------------------- */\n\ntypedef struct {\n  PyObject_HEAD\n  void *pack;\n  swig_type_info *ty;\n  size_t size;\n} PySwigPacked;\n\nSWIGRUNTIME int\nPySwigPacked_print(PySwigPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))\n{\n  char result[SWIG_BUFFER_SIZE];\n  fputs("<Swig Packed ", fp);\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {\n    fputs("at ", fp);\n    fputs(result, fp);\n  }\n  fputs(v->ty->name,fp);\n  fputs(">", fp);\n  return 0;\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_repr(PySwigPacked *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {\n    return PyString_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);\n  } else {\n    return PyString_FromFormat("<Swig Packed %s>", v->ty->name);\n  }\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_str(PySwigPacked *v)\n{\n  char result[SWIG_BUFFER_SIZE];\n  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){\n    return PyString_FromFormat("%s%s", result, v->ty->name);\n  } else {\n    return PyString_FromString(v->ty->name);\n  }\n}\n\nSWIGRUNTIME int\nPySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)\n{\n  size_t i = v->size;\n  size_t j = w->size;\n  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);\n  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);\n}\n\nSWIGRUNTIME PyTypeObject* _PySwigPacked_type(void);\n\nSWIGRUNTIME PyTypeObject*\nPySwigPacked_type(void) {\n  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigPacked_type();\n  return type;\n}\n\nSWIGRUNTIMEINLINE int\nPySwigPacked_Check(PyObject *op) {\n  return ((op)->ob_type == _PySwigPacked_type())\n    || (strcmp((op)->ob_type->tp_name,"PySwigPacked") == 0);\n}\n\nSWIGRUNTIME void\nPySwigPacked_dealloc(PyObject *v)\n{\n  if (PySwigPacked_Check(v)) {\n    PySwigPacked *sobj = (PySwigPacked *) v;\n    free(sobj->pack);\n  }\n  PyObject_DEL(v);\n}\n\nSWIGRUNTIME PyTypeObject*\n_PySwigPacked_type(void) {\n  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";\n  static PyTypeObject pyswigpacked_type;\n  static int type_init = 0;\n  if (!type_init) {\n    const PyTypeObject tmp\n      = {\n        PyObject_HEAD_INIT(NULL)\n        0,                                  /* ob_size */\n        (char *)"PySwigPacked",             /* tp_name */\n        sizeof(PySwigPacked),               /* tp_basicsize */\n        0,                                  /* tp_itemsize */\n        (destructor)PySwigPacked_dealloc,   /* tp_dealloc */\n        (printfunc)PySwigPacked_print,      /* tp_print */\n        (getattrfunc)0,                     /* tp_getattr */\n        (setattrfunc)0,                     /* tp_setattr */\n        (cmpfunc)PySwigPacked_compare,      /* tp_compare */\n        (reprfunc)PySwigPacked_repr,        /* tp_repr */\n        0,                                  /* tp_as_number */\n        0,                                  /* tp_as_sequence */\n        0,                                  /* tp_as_mapping */\n        (hashfunc)0,                        /* tp_hash */\n        (ternaryfunc)0,                     /* tp_call */\n        (reprfunc)PySwigPacked_str,         /* tp_str */\n        PyObject_GenericGetAttr,            /* tp_getattro */\n        0,                                  /* tp_setattro */\n        0,                                  /* tp_as_buffer */\n        Py_TPFLAGS_DEFAULT,                 /* tp_flags */\n        swigpacked_doc,                     /* tp_doc */\n        0,                                  /* tp_traverse */\n        0,                                  /* tp_clear */\n        0,                                  /* tp_richcompare */\n        0,                                  /* tp_weaklistoffset */\n#if PY_VERSION_HEX >= 0x02020000\n        0,                                  /* tp_iter */\n        0,                                  /* tp_iternext */\n        0,                                  /* tp_methods */\n        0,                                  /* tp_members */\n        0,                                  /* tp_getset */\n        0,                                  /* tp_base */\n        0,                                  /* tp_dict */\n        0,                                  /* tp_descr_get */\n        0,                                  /* tp_descr_set */\n        0,                                  /* tp_dictoffset */\n        0,                                  /* tp_init */\n        0,                                  /* tp_alloc */\n        0,                                  /* tp_new */\n        0,                                  /* tp_free */\n        0,                                  /* tp_is_gc */\n        0,                                  /* tp_bases */\n        0,                                  /* tp_mro */\n        0,                                  /* tp_cache */\n        0,                                  /* tp_subclasses */\n        0,                                  /* tp_weaklist */\n#endif\n#if PY_VERSION_HEX >= 0x02030000\n        0,                                  /* tp_del */\n#endif\n#ifdef COUNT_ALLOCS\n        0,0,0,0                             /* tp_alloc -> tp_next */\n#endif\n      };\n    pyswigpacked_type = tmp;\n    pyswigpacked_type.ob_type = &PyType_Type;\n    type_init = 1;\n  }\n  return &pyswigpacked_type;\n}\n\nSWIGRUNTIME PyObject *\nPySwigPacked_New(void *ptr, size_t size, swig_type_info *ty)\n{\n  PySwigPacked *sobj = PyObject_NEW(PySwigPacked, PySwigPacked_type());\n  if (sobj) {\n    void *pack = malloc(size);\n    if (pack) {\n      memcpy(pack, ptr, size);\n      sobj->pack = pack;\n      sobj->ty   = ty;\n      sobj->size = size;\n    } else {\n      PyObject_DEL((PyObject *) sobj);\n      sobj = 0;\n    }\n  }\n  return (PyObject *) sobj;\n}\n\nSWIGRUNTIME swig_type_info *\nPySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)\n{\n  if (PySwigPacked_Check(obj)) {\n    PySwigPacked *sobj = (PySwigPacked *)obj;\n    if (sobj->size != size) return 0;\n    memcpy(ptr, sobj->pack, size);\n    return sobj->ty;\n  } else {\n    return 0;\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * pointers/data manipulation\n * ----------------------------------------------------------------------------- */\n\nSWIGRUNTIMEINLINE PyObject *\n_SWIG_This(void)\n{\n  return PyString_FromString("this");\n}\n\nSWIGRUNTIME PyObject *\nSWIG_This(void)\n{\n  static PyObject *SWIG_STATIC_POINTER(swig_this) = _SWIG_This();\n  return swig_this;\n}\n\n/* #define SWIG_PYTHON_SLOW_GETSET_THIS */\n\nSWIGRUNTIME PySwigObject *\nSWIG_Python_GetSwigThis(PyObject *pyobj)\n{\n  if (PySwigObject_Check(pyobj)) {\n    return (PySwigObject *) pyobj;\n  } else {\n    PyObject *obj = 0;\n#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))\n    if (PyInstance_Check(pyobj)) {\n      obj = _PyInstance_Lookup(pyobj, SWIG_This());\n    } else {\n      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);\n      if (dictptr != NULL) {\n        PyObject *dict = *dictptr;\n        obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;\n      } else {\n#ifdef PyWeakref_CheckProxy\n        if (PyWeakref_CheckProxy(pyobj)) {\n          PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);\n          return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;\n        }\n#endif\n        obj = PyObject_GetAttr(pyobj,SWIG_This());\n        if (obj) {\n          Py_DECREF(obj);\n        } else {\n          if (PyErr_Occurred()) PyErr_Clear();\n          return 0;\n        }\n      }\n    }\n#else\n    obj = PyObject_GetAttr(pyobj,SWIG_This());\n    if (obj) {\n      Py_DECREF(obj);\n    } else {\n      if (PyErr_Occurred()) PyErr_Clear();\n      return 0;\n    }\n#endif\n    if (obj && !PySwigObject_Check(obj)) {\n      /* a PyObject is called \'this\', try to get the \'real this\'\n         PySwigObject from it */\n      return SWIG_Python_GetSwigThis(obj);\n    }\n    return (PySwigObject *)obj;\n  }\n}\n\n/* Acquire a pointer value */\n\nSWIGRUNTIME int\nSWIG_Python_AcquirePtr(PyObject *obj, int own) {\n  if (own) {\n    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);\n    if (sobj) {\n      int oldown = sobj->own;\n      sobj->own = own;\n      return oldown;\n    }\n  }\n  return 0;\n}\n\n/* Convert a pointer value */\n\nSWIGRUNTIME int\nSWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {\n  if (!obj) return SWIG_ERROR;\n  if (obj == Py_None) {\n    if (ptr) *ptr = 0;\n    return SWIG_OK;\n  } else {\n    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);\n    while (sobj) {\n      void *vptr = sobj->ptr;\n      if (ty) {\n        swig_type_info *to = sobj->ty;\n        if (to == ty) {\n          /* no type cast needed */\n          if (ptr) *ptr = vptr;\n          break;\n        } else {\n          swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n          if (!tc) {\n            sobj = (PySwigObject *)sobj->next;\n          } else {\n            if (ptr) *ptr = SWIG_TypeCast(tc,vptr);\n            break;\n          }\n        }\n      } else {\n        if (ptr) *ptr = vptr;\n        break;\n      }\n    }\n    if (sobj) {\n      if (own) *own = sobj->own;\n      if (flags & SWIG_POINTER_DISOWN) {\n        sobj->own = 0;\n      }\n      return SWIG_OK;\n    } else {\n      int res = SWIG_ERROR;\n      if (flags & SWIG_POINTER_IMPLICIT_CONV) {\n        PySwigClientData *data = ty ? (PySwigClientData *) ty->clientdata : 0;\n        if (data && !data->implicitconv) {\n          PyObject *klass = data->klass;\n          if (klass) {\n            PyObject *impconv;\n            data->implicitconv = 1; /* avoid recursion and call \'explicit\' constructors*/\n            impconv = SWIG_Python_CallFunctor(klass, obj);\n            data->implicitconv = 0;\n            if (PyErr_Occurred()) {\n              PyErr_Clear();\n              impconv = 0;\n            }\n            if (impconv) {\n              PySwigObject *iobj = SWIG_Python_GetSwigThis(impconv);\n              if (iobj) {\n                void *vptr;\n                res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);\n                if (SWIG_IsOK(res)) {\n                  if (ptr) {\n                    *ptr = vptr;\n                    /* transfer the ownership to \'ptr\' */\n                    iobj->own = 0;\n                    res = SWIG_AddCast(res);\n                    res = SWIG_AddNewMask(res);\n                  } else {\n                    res = SWIG_AddCast(res);\n                  }\n                }\n              }\n              Py_DECREF(impconv);\n            }\n          }\n        }\n      }\n      return res;\n    }\n  }\n}\n\n/* Convert a function ptr value */\n\nSWIGRUNTIME int\nSWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {\n  if (!PyCFunction_Check(obj)) {\n    return SWIG_ConvertPtr(obj, ptr, ty, 0);\n  } else {\n    void *vptr = 0;\n\n    /* here we get the method pointer for callbacks */\n    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);\n    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;\n    if (desc) {\n      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;\n      if (!desc) return SWIG_ERROR;\n    }\n    if (ty) {\n      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);\n      if (!tc) return SWIG_ERROR;\n      *ptr = SWIG_TypeCast(tc,vptr);\n    } else {\n      *ptr = vptr;\n    }\n    return SWIG_OK;\n  }\n}\n\n/* Convert a packed value value */\n\nSWIGRUNTIME int\nSWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {\n  swig_type_info *to = PySwigPacked_UnpackData(obj, ptr, sz);\n  if (!to) return SWIG_ERROR;\n  if (ty) {\n    if (to != ty) {\n      /* check type cast? */\n      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);\n      if (!tc) return SWIG_ERROR;\n    }\n  }\n  return SWIG_OK;\n}\n\n/* -----------------------------------------------------------------------------\n * Create a new pointer object\n * ----------------------------------------------------------------------------- */\n\n/*\n  Create a new instance object, whitout calling __init__, and set the\n  \'this\' attribute.\n*/\n\nSWIGRUNTIME PyObject*\nSWIG_Python_NewShadowInstance(PySwigClientData *data, PyObject *swig_this)\n{\n#if (PY_VERSION_HEX >= 0x02020000)\n  PyObject *inst = 0;\n  PyObject *newraw = data->newraw;\n  if (newraw) {\n    inst = PyObject_Call(newraw, data->newargs, NULL);\n    if (inst) {\n#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)\n      PyObject **dictptr = _PyObject_GetDictPtr(inst);\n      if (dictptr != NULL) {\n        PyObject *dict = *dictptr;\n        if (dict == NULL) {\n          dict = PyDict_New();\n          *dictptr = dict;\n          PyDict_SetItem(dict, SWIG_This(), swig_this);\n        }\n      }\n#else\n      PyObject *key = SWIG_This();\n      PyObject_SetAttr(inst, key, swig_this);\n#endif\n    }\n  } else {\n    PyObject *dict = PyDict_New();\n    PyDict_SetItem(dict, SWIG_This(), swig_this);\n    inst = PyInstance_NewRaw(data->newargs, dict);\n    Py_DECREF(dict);\n  }\n  return inst;\n#else\n#if (PY_VERSION_HEX >= 0x02010000)\n  PyObject *inst;\n  PyObject *dict = PyDict_New();\n  PyDict_SetItem(dict, SWIG_This(), swig_this);\n  inst = PyInstance_NewRaw(data->newargs, dict);\n  Py_DECREF(dict);\n  return (PyObject *) inst;\n#else\n  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);\n  if (inst == NULL) {\n    return NULL;\n  }\n  inst->in_class = (PyClassObject *)data->newargs;\n  Py_INCREF(inst->in_class);\n  inst->in_dict = PyDict_New();\n  if (inst->in_dict == NULL) {\n    Py_DECREF(inst);\n    return NULL;\n  }\n#ifdef Py_TPFLAGS_HAVE_WEAKREFS\n  inst->in_weakreflist = NULL;\n#endif\n#ifdef Py_TPFLAGS_GC\n  PyObject_GC_Init(inst);\n#endif\n  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);\n  return (PyObject *) inst;\n#endif\n#endif\n}\n\nSWIGRUNTIME void\nSWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)\n{\n PyObject *dict;\n#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)\n PyObject **dictptr = _PyObject_GetDictPtr(inst);\n if (dictptr != NULL) {\n   dict = *dictptr;\n   if (dict == NULL) {\n     dict = PyDict_New();\n     *dictptr = dict;\n   }\n   PyDict_SetItem(dict, SWIG_This(), swig_this);\n   return;\n }\n#endif\n dict = PyObject_GetAttrString(inst, (char*)"__dict__");\n PyDict_SetItem(dict, SWIG_This(), swig_this);\n Py_DECREF(dict);\n}\n\n\nSWIGINTERN PyObject *\nSWIG_Python_InitShadowInstance(PyObject *args) {\n  PyObject *obj[2];\n  if (!SWIG_Python_UnpackTuple(args,(char*)"swiginit", 2, 2, obj)) {\n    return NULL;\n  } else {\n    PySwigObject *sthis = SWIG_Python_GetSwigThis(obj[0]);\n    if (sthis) {\n      PySwigObject_append((PyObject*) sthis, obj[1]);\n    } else {\n      SWIG_Python_SetSwigThis(obj[0], obj[1]);\n    }\n    return SWIG_Py_Void();\n  }\n}\n\n/* Create a new pointer object */\n\nSWIGRUNTIME PyObject *\nSWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags) {\n  if (!ptr) {\n    return SWIG_Py_Void();\n  } else {\n    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;\n    PyObject *robj = PySwigObject_New(ptr, type, own);\n    PySwigClientData *clientdata = type ? (PySwigClientData *)(type->clientdata) : 0;\n    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {\n      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);\n      if (inst) {\n        Py_DECREF(robj);\n        robj = inst;\n      }\n    }\n    return robj;\n  }\n}\n\n/* Create a new packed object */\n\nSWIGRUNTIMEINLINE PyObject *\nSWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {\n  return ptr ? PySwigPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();\n}\n\n/* -----------------------------------------------------------------------------*\n *  Get type list\n * -----------------------------------------------------------------------------*/\n\n#ifdef SWIG_LINK_RUNTIME\nvoid *SWIG_ReturnGlobalTypeList(void *);\n#endif\n\nSWIGRUNTIME swig_module_info *\nSWIG_Python_GetModule(void) {\n  static void *type_pointer = (void *)0;\n  /* first check if module already created */\n  if (!type_pointer) {\n#ifdef SWIG_LINK_RUNTIME\n    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);\n#else\n    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,\n                                    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);\n    if (PyErr_Occurred()) {\n      PyErr_Clear();\n      type_pointer = (void *)0;\n    }\n#endif\n  }\n  return (swig_module_info *) type_pointer;\n}\n\n#if PY_MAJOR_VERSION < 2\n/* PyModule_AddObject function was introduced in Python 2.0.  The following function\n   is copied out of Python/modsupport.c in python version 2.3.4 */\nSWIGINTERN int\nPyModule_AddObject(PyObject *m, char *name, PyObject *o)\n{\n  PyObject *dict;\n  if (!PyModule_Check(m)) {\n    PyErr_SetString(PyExc_TypeError,\n                    "PyModule_AddObject() needs module as first arg");\n    return SWIG_ERROR;\n  }\n  if (!o) {\n    PyErr_SetString(PyExc_TypeError,\n                    "PyModule_AddObject() needs non-NULL value");\n    return SWIG_ERROR;\n  }\n\n  dict = PyModule_GetDict(m);\n  if (dict == NULL) {\n    /* Internal error -- modules must have a dict! */\n    PyErr_Format(PyExc_SystemError, "module \'%s\' has no __dict__",\n                 PyModule_GetName(m));\n    return SWIG_ERROR;\n  }\n  if (PyDict_SetItemString(dict, name, o))\n    return SWIG_ERROR;\n  Py_DECREF(o);\n  return SWIG_OK;\n}\n#endif\n\nSWIGRUNTIME void\nSWIG_Python_DestroyModule(void *vptr)\n{\n  swig_module_info *swig_module = (swig_module_info *) vptr;\n  swig_type_info **types = swig_module->types;\n  size_t i;\n  for (i =0; i < swig_module->size; ++i) {\n    swig_type_info *ty = types[i];\n    if (ty->owndata) {\n      PySwigClientData *data = (PySwigClientData *) ty->clientdata;\n      if (data) PySwigClientData_Del(data);\n    }\n  }\n  Py_DECREF(SWIG_This());\n}\n\nSWIGRUNTIME void\nSWIG_Python_SetModule(swig_module_info *swig_module) {\n  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */\n\n  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,\n                                   swig_empty_runtime_method_table);\n  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);\n  if (pointer && module) {\n    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);\n  } else {\n    Py_XDECREF(pointer);\n  }\n}\n\n/* The python cached type query */\nSWIGRUNTIME PyObject *\nSWIG_Python_TypeCache(void) {\n  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();\n  return cache;\n}\n\nSWIGRUNTIME swig_type_info *\nSWIG_Python_TypeQuery(const char *type)\n{\n  PyObject *cache = SWIG_Python_TypeCache();\n  PyObject *key = PyString_FromString(type);\n  PyObject *obj = PyDict_GetItem(cache, key);\n  swig_type_info *descriptor;\n  if (obj) {\n    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);\n  } else {\n    swig_module_info *swig_module = SWIG_Python_GetModule();\n    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);\n    if (descriptor) {\n      obj = PyCObject_FromVoidPtr(descriptor, NULL);\n      PyDict_SetItem(cache, key, obj);\n      Py_DECREF(obj);\n    }\n  }\n  Py_DECREF(key);\n  return descriptor;\n}\n\n/*\n   For backward compatibility only\n*/\n#define SWIG_POINTER_EXCEPTION  0\n#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)\n#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)\n\nSWIGRUNTIME int\nSWIG_Python_AddErrMesg(const char* mesg, int infront)\n{\n  if (PyErr_Occurred()) {\n    PyObject *type = 0;\n    PyObject *value = 0;\n    PyObject *traceback = 0;\n    PyErr_Fetch(&type, &value, &traceback);\n    if (value) {\n      PyObject *old_str = PyObject_Str(value);\n      Py_XINCREF(type);\n      PyErr_Clear();\n      if (infront) {\n        PyErr_Format(type, "%s %s", mesg, PyString_AsString(old_str));\n      } else {\n        PyErr_Format(type, "%s %s", PyString_AsString(old_str), mesg);\n      }\n      Py_DECREF(old_str);\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nSWIGRUNTIME int\nSWIG_Python_ArgFail(int argnum)\n{\n  if (PyErr_Occurred()) {\n    /* add information about failing argument */\n    char mesg[256];\n    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);\n    return SWIG_Python_AddErrMesg(mesg, 1);\n  } else {\n    return 0;\n  }\n}\n\nSWIGRUNTIMEINLINE const char *\nPySwigObject_GetDesc(PyObject *self)\n{\n  PySwigObject *v = (PySwigObject *)self;\n  swig_type_info *ty = v ? v->ty : 0;\n  return ty ? ty->str : (char*)"";\n}\n\nSWIGRUNTIME void\nSWIG_Python_TypeError(const char *type, PyObject *obj)\n{\n  if (type) {\n#if defined(SWIG_COBJECT_TYPES)\n    if (obj && PySwigObject_Check(obj)) {\n      const char *otype = (const char *) PySwigObject_GetDesc(obj);\n      if (otype) {\n        PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'PySwigObject(%s)\' is received",\n                     type, otype);\n        return;\n      }\n    } else\n#endif\n    {\n      const char *otype = (obj ? obj->ob_type->tp_name : 0);\n      if (otype) {\n        PyObject *str = PyObject_Str(obj);\n        const char *cstr = str ? PyString_AsString(str) : 0;\n        if (cstr) {\n          PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'%s(%s)\' is received",\n                       type, otype, cstr);\n        } else {\n          PyErr_Format(PyExc_TypeError, "a \'%s\' is expected, \'%s\' is received",\n                       type, otype);\n        }\n        Py_XDECREF(str);\n        return;\n      }\n    }\n    PyErr_Format(PyExc_TypeError, "a \'%s\' is expected", type);\n  } else {\n    PyErr_Format(PyExc_TypeError, "unexpected type is received");\n  }\n}\n\n\n/* Convert a pointer value, signal an exception on a type mismatch */\nSWIGRUNTIME void *\nSWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {\n  void *result;\n  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {\n    PyErr_Clear();\n    if (flags & SWIG_POINTER_EXCEPTION) {\n      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);\n      SWIG_Python_ArgFail(argnum);\n    }\n  }\n  return result;\n}\n\n\n#ifdef __cplusplus\n#if 0\n{ /* cc-mode */\n#endif\n}\n#endif\n/* -----------------------------------------------------------------------------*\n   Standard SWIG API for use inside user code.\n\n   Don\'t include this file directly, run the command\n   swig -python -external-runtime\n   Also, read the Modules chapter of the SWIG Manual.\n\n * -----------------------------------------------------------------------------*/\n\n#ifdef SWIG_MODULE_CLIENTDATA_TYPE\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_TypeQuery(SWIG_MODULE_CLIENTDATA_TYPE clientdata, const char *name) {\n  swig_module_info *module = SWIG_GetModule(clientdata);\n  return SWIG_TypeQueryModule(module, module, name);\n}\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_MangledTypeQuery(SWIG_MODULE_CLIENTDATA_TYPE clientdata, const char *name) {\n  swig_module_info *module = SWIG_GetModule(clientdata);\n  return SWIG_MangledTypeQueryModule(module, module, name);\n}\n\n#else\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_TypeQuery(const char *name) {\n  swig_module_info *module = SWIG_GetModule(NULL);\n  return SWIG_TypeQueryModule(module, module, name);\n}\n\nSWIGRUNTIMEINLINE swig_type_info *\nSWIG_MangledTypeQuery(const char *name) {\n  swig_module_info *module = SWIG_GetModule(NULL);\n  return SWIG_MangledTypeQueryModule(module, module, name);\n}\n\n#endif\n\n'